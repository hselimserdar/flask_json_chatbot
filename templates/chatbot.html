<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HSS GPT</title>
    <link rel="icon" type="image/png" href="{{ url_for('static', filename='icons/50px-logo.png') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <!-- pick a style you like; here's GitHub-Dark -->
    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
    <!-- load any extras if you want, but core already includes most langs -->
    <!-- Arduino language definition -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/arduino.min.js"></script>
    <script>hljs.highlightAll();</script>

</head>

<body>
    <div class="chat-container">
        <header class="chat-header">
            <div class="header-left">
                <button id="mobileMenuBtn" class="mobile-menu-btn">‚ò∞</button>
                <a href="{{ url_for('home') }}" class="logo-link">
                    <img src="{{ url_for('static', filename='icons/50px-logo.png') }}" alt="HSS GPT Logo" class="chat-logo">
                </a>
                <h1>HSS GPT</h1>
                <span id="userInfo" class="user-info"></span>
            </div>
            <div class="header-right">
                <button id="newSessionBtn" class="btn btn-secondary">New Chat</button>
                <button id="logoutBtn" class="btn btn-outline">Logout</button>
            </div>
        </header>

        <div class="chat-layout">
            <aside id="sessionsSidebar" class="sessions-sidebar open">
                <div class="sidebar-header">
                    <h3>Your Sessions</h3>
                </div>
                <div id="sessionsList" class="sessions-list">
                    <!-- Sessions will be loaded here -->
                </div>
                <div class="sidebar-pagination">
                    <button id="prevPage" class="btn btn-outline btn-small">Previous</button>
                    <span id="pageInfo">Page 1</span>
                    <button id="nextPage" class="btn btn-outline btn-small">Next</button>
                </div>
            </aside>

            <main class="chat-main">
                <div id="chatMessages" class="chat-messages">
                    <div class="welcome-message">
                        <h3>Welcome to HSS GPT! üëã</h3>
                        <p>Start a conversation by typing a message below.</p>
                    </div>
                </div>

                <div class="chat-input-container">
                    <div class="input-wrapper">
                        <textarea id="messageInput" placeholder="Type your message here..." rows="1"></textarea>
                        <button id="sendBtn" class="send-btn">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2">
                                <line x1="22" y1="2" x2="11" y2="13"></line>
                                <polygon points="22,2 15,22 11,13 2,9"></polygon>
                            </svg>
                        </button>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <script>
        let currentSessionId = null;
        let currentPage = 1;
        let isGuest = false;
        let currentTreePath = null;
        let currentConversationBranches = {};  // Store branch structure
        let currentSessionMessages = [];  // Store complete session messages for branch navigation

        // Check authentication on page load
        window.addEventListener('load', function () {
            const token = localStorage.getItem('token');
            if (!token) {
                // Check if this is guest mode
                const urlParams = new URLSearchParams(window.location.search);
                if (urlParams.get('mode') === 'guest') {
                    isGuest = true;
                    currentSessionId = 'guest';
                    document.getElementById('userInfo').textContent = 'Guest User';
                    document.getElementById('newSessionBtn').style.display = 'none';
                    document.getElementById('mobileMenuBtn').style.display = 'none';
                    // Hide sessions sidebar for guest users
                    document.getElementById('sessionsSidebar').style.display = 'none';
                    document.querySelector('.chat-main').classList.remove('with-sidebar');
                } else {
                    window.location.href = '/login';
                    return;
                }
            } else {
                // Verify token and get user info
                verifyToken();
                // Load sessions immediately for authenticated users
                loadSessions(currentPage);
                // Mark chat main as having sidebar
                document.querySelector('.chat-main').classList.add('with-sidebar');
            }

            setupEventListeners();
            adjustTextareaHeight();
            checkIfWaitingForResponse();
        });

        async function verifyToken() {
            const token = localStorage.getItem('token');
            if (!token) {
                console.error('No token found in localStorage');
                localStorage.removeItem('token');
                window.location.href = '/login';
                return;
            }
            
            try {
                const response = await fetch('/verify-token', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();

                if (response.ok && data.valid) {
                    // Token is valid, update user info with username
                    const userInfoElement = document.getElementById('userInfo');
                    userInfoElement.textContent = `Welcome, ${data.username}`;
                    userInfoElement.title = `Token expires in ${data.time_remaining_minutes} minutes (${data.remaining_percentage}% remaining)`;
                    
                    console.log('Token verification successful:', {
                        username: data.username,
                        expires_at: data.expires_at,
                        time_remaining_minutes: data.time_remaining_minutes,
                        remaining_percentage: data.remaining_percentage,
                        needs_refresh: data.needs_refresh
                    });
                    
                    // Check if token needs refresh (less than 20% lifetime remaining)
                    if (data.needs_refresh) {
                        console.log(`Token has ${data.remaining_percentage}% remaining, refreshing automatically...`);
                        await automaticTokenRefresh();
                    } else {
                        // Set up token expiration warning
                        setupTokenExpirationWarning(data.time_remaining_seconds);
                    }
                    
                } else {
                    // Token is invalid or expired
                    console.error('Token verification failed:', data.message);
                    
                    // Show error message to user
                    if (data.message === 'Token expired') {
                        showErrorMessage('Your session has expired. Please log in again.');
                    } else {
                        showErrorMessage('Authentication failed. Please log in again.');
                    }
                    
                    // Clear invalid token and redirect
                    localStorage.removeItem('token');
                    setTimeout(() => {
                        window.location.href = '/login';
                    }, 2000);
                }
            } catch (error) {
                console.error('Token verification request failed:', error);
                
                // Network error - could be temporary, show warning but don't immediately redirect
                showErrorMessage('Unable to verify authentication. Please check your connection.');
                
                // Still set a fallback display name
                document.getElementById('userInfo').textContent = 'Authenticated User (Unverified)';
                
                // Set up retry mechanism
                setTimeout(() => {
                    verifyToken(); // Retry verification after 30 seconds
                }, 30000);
            }
        }

        async function automaticTokenRefresh() {
            try {
                const currentToken = localStorage.getItem('token');
                const response = await fetch('/refresh-token', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${currentToken}`,
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();

                if (response.ok && data.token) {
                    // Update token in localStorage
                    localStorage.setItem('token', data.token);
                    
                    console.log('Token refreshed automatically:', {
                        username: data.username,
                        expires_at: data.expires_at,
                        message: data.message
                    });
                    
                    // Show success notification
                    showTokenRefreshNotification();
                    
                    // Re-verify with new token to get updated timing info
                    setTimeout(() => {
                        verifyToken();
                    }, 1000);
                    
                } else {
                    console.error('Automatic token refresh failed:', data.message);
                    
                    if (data.message.includes('expired too long ago')) {
                        showErrorMessage('Session expired. Please log in again.');
                        localStorage.removeItem('token');
                        setTimeout(() => {
                            window.location.href = '/login';
                        }, 2000);
                    } else {
                        showErrorMessage('Unable to refresh session. Please log in again.');
                        setTimeout(() => {
                            localStorage.removeItem('token');
                            window.location.href = '/login';
                        }, 3000);
                    }
                }
            } catch (error) {
                console.error('Automatic token refresh error:', error);
                showErrorMessage('Network error during session refresh. Please check your connection.');
            }
        }

        function showTokenRefreshNotification() {
            const notificationDiv = document.createElement('div');
            notificationDiv.className = 'token-refresh-notification';
            notificationDiv.innerHTML = `
                <div class="refresh-content">
                    <span class="refresh-icon">üîÑ</span>
                    <span class="refresh-text">Session refreshed automatically</span>
                    <button class="refresh-close" onclick="this.parentElement.parentElement.remove()">√ó</button>
                </div>
            `;

            // Insert at the top of chat container
            const chatContainer = document.querySelector('.chat-container');
            chatContainer.insertBefore(notificationDiv, chatContainer.firstChild);

            // Auto-hide after 3 seconds
            setTimeout(() => {
                if (notificationDiv.parentNode) {
                    notificationDiv.remove();
                }
            }, 3000);
        }

        // Enhanced request wrapper that checks token status before every request
        async function makeAuthenticatedRequest(url, options = {}) {
            const token = localStorage.getItem('token');
            if (!token) {
                throw new Error('No authentication token available');
            }

            // Check token status before making the request
            const tokenCheckResponse = await fetch('/verify-token', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json'
                }
            });

            if (tokenCheckResponse.ok) {
                const tokenData = await tokenCheckResponse.json();
                
                // If token needs refresh, do it before the actual request
                if (tokenData.needs_refresh) {
                    console.log(`Token needs refresh before request to ${url}, refreshing...`);
                    await automaticTokenRefresh();
                }
            }

            // Make the actual request with current token
            const currentToken = localStorage.getItem('token');
            const requestOptions = {
                ...options,
                headers: {
                    ...options.headers,
                    'Authorization': `Bearer ${currentToken}`,
                    'Content-Type': 'application/json'
                }
            };

            return fetch(url, requestOptions);
        }

        function setupTokenExpirationWarning(timeRemainingSeconds) {
            // Clear any existing warning timers
            if (window.tokenWarningTimer) {
                clearTimeout(window.tokenWarningTimer);
            }
            if (window.tokenExpirationTimer) {
                clearTimeout(window.tokenExpirationTimer);
            }
            
            // Show warning 5 minutes before expiration
            const warningTime = Math.max(0, (timeRemainingSeconds - 300) * 1000); // 5 minutes = 300 seconds
            
            if (warningTime > 0) {
                window.tokenWarningTimer = setTimeout(() => {
                    showTokenExpirationWarning();
                }, warningTime);
            } else if (timeRemainingSeconds > 60) {
                // If less than 5 minutes remaining, show warning immediately
                showTokenExpirationWarning();
            }
            
            // Auto-logout when token expires
            window.tokenExpirationTimer = setTimeout(() => {
                showErrorMessage('Your session has expired. Redirecting to login...');
                localStorage.removeItem('token');
                setTimeout(() => {
                    window.location.href = '/login';
                }, 2000);
            }, timeRemainingSeconds * 1000);
        }

        function showTokenExpirationWarning() {
            const warningDiv = document.createElement('div');
            warningDiv.className = 'token-warning-notification';
            warningDiv.innerHTML = `
                <div class="warning-content">
                    <span class="warning-icon">‚è∞</span>
                    <span class="warning-text">Your session will expire soon. Save your work!</span>
                    <button class="warning-refresh" onclick="refreshToken()">Extend Session</button>
                    <button class="warning-close" onclick="this.parentElement.parentElement.remove()">√ó</button>
                </div>
            `;

            // Insert at the top of chat container
            const chatContainer = document.querySelector('.chat-container');
            chatContainer.insertBefore(warningDiv, chatContainer.firstChild);

            // Auto-hide after 10 seconds
            setTimeout(() => {
                if (warningDiv.parentNode) {
                    warningDiv.remove();
                }
            }, 10000);
        }

        async function refreshToken() {
            try {
                // Call the login endpoint to get a new token (simulating token refresh)
                const currentToken = localStorage.getItem('token');
                const response = await fetch('/verify-token', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${currentToken}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (response.ok) {
                    const data = await response.json();
                    if (data.valid && data.time_remaining_minutes > 5) {
                        showErrorMessage('Session verified - you have time remaining!', false);
                        setupTokenExpirationWarning(data.time_remaining_seconds);
                    } else {
                        showErrorMessage('Session is about to expire. Please save your work and log in again.');
                    }
                } else {
                    showErrorMessage('Unable to refresh session. Please log in again.');
                    setTimeout(() => {
                        localStorage.removeItem('token');
                        window.location.href = '/login';
                    }, 3000);
                }
            } catch (error) {
                console.error('Token refresh failed:', error);
                showErrorMessage('Network error. Please check your connection.');
            }

            // Remove any warning notifications
            const warnings = document.querySelectorAll('.token-warning-notification');
            warnings.forEach(warning => warning.remove());
        }

        function setupEventListeners() {
            // Send message
            document.getElementById('sendBtn').addEventListener('click', sendMessage);
            document.getElementById('messageInput').addEventListener('keypress', function (e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            });

            // Auto-resize textarea
            document.getElementById('messageInput').addEventListener('input', adjustTextareaHeight);

            // New session
            document.getElementById('newSessionBtn').addEventListener('click', startNewSession);

            // Logout
            document.getElementById('logoutBtn').addEventListener('click', logout);

            // Pagination (only for authenticated users)
            if (!isGuest) {
                document.getElementById('prevPage').addEventListener('click', () => changePage(currentPage - 1));
                document.getElementById('nextPage').addEventListener('click', () => changePage(currentPage + 1));

                // Mobile menu toggle
                document.getElementById('mobileMenuBtn').addEventListener('click', toggleMobileSidebar);

                // Close mobile sidebar when clicking outside
                document.addEventListener('click', function (e) {
                    if (window.innerWidth <= 768) {
                        const sidebar = document.getElementById('sessionsSidebar');
                        const menuBtn = document.getElementById('mobileMenuBtn');
                        if (!sidebar.contains(e.target) && !menuBtn.contains(e.target)) {
                            sidebar.classList.remove('mobile-open');
                        }
                    }
                });
            }
        }

        async function sendMessage() {
            const messageInput = document.getElementById('messageInput');
            const message = messageInput.value.trim();

            if (!message) return;

            // Check if we're already waiting for a response
            if (isWaitingForResponse()) {
                return;
            }

            // Add user message to chat
            const userMessageDiv = addMessageToChat('user', message);

            messageInput.value = '';
            adjustTextareaHeight();

            // Block input while waiting for response
            setWaitingForResponse(true);

            // Show typing indicator
            showTypingIndicator();

            try {
                const url = currentSessionId ? `/chatbot?session=${currentSessionId}` : '/chatbot';
                let response;
                
                // Prepare request body with message and parent_message_id if needed
                const requestBody = { message };
                
                // If we have a tree path, we need to find the last bot message to use as parent
                if (currentTreePath && currentSessionId) {
                    const lastBotMessage = getLastBotMessageFromCurrentBranch();
                    if (lastBotMessage) {
                        requestBody.parent_message_id = lastBotMessage.id;
                    }
                }
                
                if (isGuest) {
                    // Guest users don't need token refresh
                    response = await fetch(url, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(requestBody)
                    });
                } else {
                    // Authenticated users use the enhanced request wrapper
                    response = await makeAuthenticatedRequest(url, {
                        method: 'POST',
                        body: JSON.stringify(requestBody)
                    });
                }

                const data = await response.json();
                hideTypingIndicator();

                if (response.ok) {
                    if (data.session_id && !currentSessionId) {
                        currentSessionId = data.session_id;
                        updateURL();
                        // Reload sessions to show the new session
                        loadSessions(currentPage);
                    }
                    
                    // Check if session title has changed and update sidebar
                    if (data.title && currentSessionId && data.session_id === currentSessionId) {
                        updateSessionTitleInSidebar(currentSessionId, data.title);
                    }
                    
                    // Process branching response
                    let botMessage = '';
                    let botMessageData = null;
                    let userMessageData = null;
                    
                    if (data.messages && data.messages.length > 1) {
                        // Get user and bot message from messages array
                        const userMsg = data.messages.find(msg => msg.sender === 'user');
                        const botMsg = data.messages.find(msg => msg.sender === 'bot');
                        botMessage = botMsg ? botMsg.content : '';
                        botMessageData = botMsg;
                        userMessageData = userMsg;
                        
                        // Update the user message div with proper data for edit controls
                        if (userMessageData && !isGuest) {
                            const lastUserDiv = document.querySelector('.message.user-message:last-of-type');
                            if (lastUserDiv) {
                                // Updating user message with enhanced data
                                // Add message data attributes - convert message_id to id for consistency
                                lastUserDiv.dataset.messageId = userMessageData.message_id || userMessageData.id;
                                lastUserDiv.dataset.connectedFrom = userMessageData.connected_from || '';
                                lastUserDiv.dataset.connectsTo = userMessageData.connects_to || '';
                                lastUserDiv.dataset.connections = userMessageData.connections || 0;
                                
                                // Create a normalized messageData object with 'id' field
                                const normalizedUserData = {
                                    id: userMessageData.message_id || userMessageData.id,
                                    connected_from: userMessageData.connected_from,
                                    connects_to: userMessageData.connects_to,
                                    connections: userMessageData.connections
                                };
                                
                                // Add edit controls if they don't already exist AND it's not the first message
                                if (!lastUserDiv.querySelector('.user-edit-controls')) {
                                    // Adding edit controls to user message
                                    
                                    // Check if this is the first message (connected_from === 'main') or new session
                                    if (normalizedUserData.connected_from !== 'main' && currentSessionId) {
                                        const editControlsDiv = addUserMessageEditControls(lastUserDiv, normalizedUserData, message);
                                        if (editControlsDiv) {
                                            lastUserDiv.appendChild(editControlsDiv);
                                            // Edit controls added successfully
                                        } else {
                                            // Failed to create edit controls - configuration issue
                                        }
                                    } else {
                                        // Edit controls NOT added - first message or new session
                                    }
                                } else {
                                    // Edit controls already exist
                                }
                            } else {
                                // Could not find last user message div
                            }
                        } else {
                            console.log('No user message data or guest mode - userMessageData:', !!userMessageData, 'isGuest:', isGuest);
                        }
                    } else {
                        // Fallback to direct reply field
                        botMessage = data.reply || '';
                    }

                    if (botMessage) {
                        const botDiv = addMessageToChat('bot', botMessage, null, false, botMessageData);
                        
                        // Update stored session messages for branching functionality
                        if (data.messages) {
                            // Add the new messages to our stored session messages
                            data.messages.forEach(newMsg => {
                                // Check if message already exists (avoid duplicates)
                                const existingIndex = currentSessionMessages.findIndex(msg => 
                                    (msg.id || msg.message_id) === (newMsg.id || newMsg.message_id)
                                );
                                if (existingIndex === -1) {
                                    currentSessionMessages.push(newMsg);
                                } else {
                                    // Update existing message with new data
                                    currentSessionMessages[existingIndex] = newMsg;
                                }
                            });
                            
                            updateBranchStructure(data.messages);
                        }
                        
                        // Update tree path display if needed
                        updateTreePathDisplay();
                    } else {
                        showErrorMessage('Received empty response from the chatbot. Please try again.');
                    }
                } else {
                    // Check for authentication/authorization errors (403/404)
                    if (response.status === 403 || response.status === 404) {
                        const errorMessage = data.message || 'Access denied';
                        if (shouldRedirectToLogin(errorMessage)) {
                            localStorage.removeItem('token');
                            window.location.href = '/login';
                            return;
                        }
                    }
                    
                    // Check for 500 errors - add action buttons to user message
                    if (response.status === 500) {
                        addActionButtonsToMessage(userMessageDiv, message);
                        showErrorMessage(data.message || 'Server error occurred. You can try again, edit, or delete this message.', true);
                    } else {
                        showErrorMessage(data.message || 'An error occurred');
                    }
                }
            } catch (error) {
                hideTypingIndicator();
                // Network or other errors - add action buttons
                addActionButtonsToMessage(userMessageDiv, message);
                showErrorMessage('Failed to send message. Please try again.', true);
                console.error('Send message error:', error);
            } finally {
                // Unblock input after response (success or error)
                setWaitingForResponse(false);
            }
        }

        function addMessageToChat(sender, message, timestamp = null, showActions = false, messageData = null) {
            const chatMessages = document.getElementById('chatMessages');

            // Remove welcome message if it exists
            const welcomeMessage = chatMessages.querySelector('.welcome-message');
            if (welcomeMessage) {
                welcomeMessage.remove();
            }

            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${sender}-message`;
            
            // Add message data attributes for branching
            if (messageData) {
                messageDiv.dataset.messageId = messageData.id;
                messageDiv.dataset.connectedFrom = messageData.connected_from || '';
                messageDiv.dataset.connectsTo = messageData.connects_to || '';
                messageDiv.dataset.connections = messageData.connections || 0;
            }

            const messageContent = document.createElement('div');
            messageContent.className = 'message-content';

            // Process message for code blocks
            const processedMessage = processCodeBlocks(message);
            messageContent.innerHTML = processedMessage;

            const timestampDiv = document.createElement('div');
            timestampDiv.className = 'message-timestamp';

            // Use provided timestamp or current time for new messages
            if (timestamp) {
                const messageTime = new Date(timestamp);
                timestampDiv.textContent = messageTime.toLocaleString();
            } else {
                timestampDiv.textContent = new Date().toLocaleTimeString();
            }

            messageDiv.appendChild(messageContent);
            messageDiv.appendChild(timestampDiv);

            // Add branch navigation for user messages that connect FROM bot messages with multiple branches (ChatGPT style)
            if (sender === 'user' && messageData && messageData.connected_from) {
                // Find the bot message this user message connects from
                const allMessages = getCurrentSessionMessages();
                const parentBotMessage = allMessages.find(msg => 
                    msg.id.toString() === messageData.connected_from.toString() && msg.sender === 'bot'
                );
                
                if (parentBotMessage && parentBotMessage.connections > 1) {
                    // Adding branch navigation for user message
                    const navigationDiv = addBranchNavigationControls(messageDiv, {
                        id: messageData.id,
                        connects_to: parentBotMessage.connects_to,
                        connections: parentBotMessage.connections,
                        parent_bot_id: parentBotMessage.id
                    });
                    if (navigationDiv) {
                        messageDiv.appendChild(navigationDiv);
                        // Branch navigation added successfully
                    } else {
                        // addBranchNavigationControls returned null
                    }
                } else {
                    console.log('No branch navigation needed - parent bot has', parentBotMessage?.connections || 0, 'connections');
                }
            } else {
                console.log('Branch navigation NOT checked - sender:', sender, 'messageData:', !!messageData, 'connected_from:', messageData?.connected_from);
            }

            // Add ChatGPT-style edit button for user messages (not guest mode, not first message, and not new session)
            if (sender === 'user' && !isGuest && messageData && messageData.connected_from !== 'main' && currentSessionId) {
                // Adding edit controls for user message
                const editControlsDiv = addUserMessageEditControls(messageDiv, messageData, message);
                if (editControlsDiv) {
                    messageDiv.appendChild(editControlsDiv);
                    // Edit controls added successfully
                } else {
                    // addUserMessageEditControls returned null
                }
            } else {
                console.log('Edit controls NOT added - sender:', sender, 'isGuest:', isGuest, 'messageData:', !!messageData, 'connected_from:', messageData?.connected_from, 'currentSessionId:', currentSessionId);
            }

            // Add action buttons for user messages that failed to send
            if (showActions && sender === 'user') {
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'message-actions';
                actionsDiv.innerHTML = `
                    <button class="action-btn delete-btn" onclick="deleteMessage(this)" title="Delete message">üóëÔ∏è</button>
                    <button class="action-btn retry-btn" onclick="retryMessage(this, '${message.replace(/'/g, "\\'")}', '${messageDiv.dataset.originalMessage || message}')" title="Try again">üîÑ</button>
                    <button class="action-btn edit-btn" onclick="editMessage(this, '${message.replace(/'/g, "\\'")}', '${messageDiv.dataset.originalMessage || message}')" title="Edit message">‚úèÔ∏è</button>
                `;
                messageDiv.appendChild(actionsDiv);
                messageDiv.dataset.originalMessage = message;
            }

            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            const newBlocks = messageDiv.querySelectorAll("pre code");
            newBlocks.forEach(block => hljs.highlightElement(block));

            return messageDiv;
        }

        function showErrorMessage(message, hasActionButtons = false) {
            // Check if this is an authentication/authorization error that should redirect to login
            if (shouldRedirectToLogin(message)) {
                localStorage.removeItem('token'); // Clear any invalid token
                window.location.href = '/login';
                return;
            }

            // Check if this is an API failure that should refresh the page
            // BUT only if we don't have action buttons available for the user
            if (!hasActionButtons && shouldRefreshPage(message)) {
                setTimeout(() => {
                    window.location.reload();
                }, 2000); // Give user 2 seconds to see the error message
            }

            // Remove any existing error messages
            const existingError = document.querySelector('.error-notification');
            if (existingError) {
                existingError.remove();
            }

            // Create error notification
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-notification';
            errorDiv.innerHTML = `
                <div class="error-content">
                    <span class="error-icon">‚ö†Ô∏è</span>
                    <span class="error-text">${message}</span>
                    <button class="error-close" onclick="this.parentElement.parentElement.remove()">√ó</button>
                </div>
            `;

            // Insert at the top of chat container
            const chatContainer = document.querySelector('.chat-container');
            chatContainer.insertBefore(errorDiv, chatContainer.firstChild);

            // Auto-hide after 5 seconds (unless page is refreshing)
            if (!(!hasActionButtons && shouldRefreshPage(message))) {
                setTimeout(() => {
                    if (errorDiv.parentNode) {
                        errorDiv.remove();
                    }
                }, 5000);
            }
        }

        function shouldRedirectToLogin(message) {
            // List of error messages that indicate authentication/authorization issues
            const authErrorMessages = [
                "Forbidden: Guest users cannot access session messages.",
                "Forbidden: You do not have access to this session.",
                "Guest users cannot create or access sessions.",
                "No active session available for guest users."
            ];
            
            return authErrorMessages.some(authMsg => message.includes(authMsg));
        }

        function shouldRefreshPage(message) {
            // List of error messages that indicate API failures requiring page refresh
            const apiFailureMessages = [
                "Failed to get a reply from the API."
            ];
            
            return apiFailureMessages.some(apiMsg => message.includes(apiMsg));
        }

        function showTypingIndicator() {
            const chatMessages = document.getElementById('chatMessages');
            const typingDiv = document.createElement('div');
            typingDiv.className = 'message bot-message typing-indicator';
            typingDiv.id = 'typingIndicator';
            typingDiv.innerHTML = '<div class="message-content">Typing<span class="dots">...</span></div>';
            chatMessages.appendChild(typingDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function hideTypingIndicator() {
            const typingIndicator = document.getElementById('typingIndicator');
            if (typingIndicator) {
                typingIndicator.remove();
            }
        }

        function adjustTextareaHeight() {
            const textarea = document.getElementById('messageInput');
            textarea.style.height = 'auto';
            textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
        }

        async function loadSessions(page = 1) {
            if (isGuest) return;

            console.log(`Loading sessions for page: ${page}`);

            try {
                const response = await makeAuthenticatedRequest(`/chatbot/session?page=${page}`, {
                    method: 'GET'
                });

                const data = await response.json();
                console.log('Sessions response:', data);

                if (response.ok) {
                    displaySessions(data.sessions || []);
                    currentPage = page;
                    console.log(`Updated currentPage to: ${currentPage}, has_next: ${data.has_next}, has_previous: ${data.has_previous}`);
                    updatePagination(data.has_next, data.has_previous);
                } else {
                    // Check for authentication/authorization errors
                    if (response.status === 403 || response.status === 404) {
                        const errorMessage = data.message || 'Access denied';
                        if (shouldRedirectToLogin(errorMessage)) {
                            localStorage.removeItem('token');
                            window.location.href = '/login';
                            return;
                        }
                    }
                    document.getElementById('sessionsList').innerHTML =
                        '<div class="no-sessions">No sessions found</div>';
                }
            } catch (error) {
                console.error('Load sessions error:', error);
                showErrorMessage('Failed to load sessions. Please try again.');
                document.getElementById('sessionsList').innerHTML =
                    '<div class="error-sessions">Failed to load sessions</div>';
            }
        }

        function displaySessions(sessions) {
            const sessionsList = document.getElementById('sessionsList');
            sessionsList.innerHTML = '';

            // Sort sessions by created_at in descending order (newest first)
            const sortedSessions = sessions.sort((a, b) => {
                const dateA = new Date(a.created_at || 0);
                const dateB = new Date(b.created_at || 0);
                return dateB - dateA; // Newest first
            });

            sortedSessions.forEach(session => {
                const sessionDiv = document.createElement('div');
                sessionDiv.className = 'session-item';
                sessionDiv.setAttribute('data-session-id', session.id);
                if (session.id === currentSessionId) {
                    sessionDiv.classList.add('active');
                }

                // Handle created_at properly
                const createdAt = session.created_at ? new Date(session.created_at).toLocaleDateString() : 'Unknown date';

                sessionDiv.innerHTML = `
                    <div class="session-content">
                        <div class="session-title">${session.title || 'Session ' + session.id}</div>
                        <div class="session-date">${createdAt}</div>
                    </div>
                    <button class="session-delete-btn" title="Delete session" onclick="deleteSession(event, '${session.id}')">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="3,6 5,6 21,6"></polyline>
                            <path d="m19,6v14a2,2 0 0,1-2,2H7a2,2 0 0,1-2-2V6m3,0V4a2,2 0 0,1,2-2h4a2,2 0 0,1,2,2v2"></path>
                            <line x1="10" y1="11" x2="10" y2="17"></line>
                            <line x1="14" y1="11" x2="14" y2="17"></line>
                        </svg>
                    </button>
                `;

                sessionDiv.addEventListener('click', (e) => {
                    // Don't load session if delete button was clicked
                    if (!e.target.closest('.session-delete-btn')) {
                        loadSession(session.id);
                    }
                });
                sessionsList.appendChild(sessionDiv);
            });
        }

        function updateSessionTitleInSidebar(sessionId, newTitle) {
            // Find the session div with the matching data-session-id attribute
            const sessionDiv = document.querySelector(`[data-session-id="${sessionId}"]`);
            if (sessionDiv) {
                // Update the session title in the sidebar
                const titleElement = sessionDiv.querySelector('.session-title');
                if (titleElement) {
                    titleElement.textContent = newTitle || `Session ${sessionId}`;
                }
            }
        }

        async function deleteSession(event, sessionId) {
            event.stopPropagation(); // Prevent triggering the session click event
            
            // Show confirmation dialog
            if (!confirm('Are you sure you want to delete this session? This action cannot be undone.')) {
                return;
            }
            
            try {
                const response = await makeAuthenticatedRequest(`/chatbot/delete?session=${sessionId}`, {
                    method: 'GET'
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    // Show success message
                    showSuccessMessage(data.message || 'Session deleted successfully');
                    
                    // If this was the current session, clear the chat and redirect to new session
                    if (currentSessionId === sessionId) {
                        currentSessionId = null;
                        updateURL();
                        // Clear chat messages
                        const chatMessages = document.getElementById('chatMessages');
                        chatMessages.innerHTML = `
                            <div class="welcome-message">
                                <h3>Welcome to HSS GPT! üëã</h3>
                                <p>How can I help you today?</p>
                            </div>
                        `;
                    }
                    
                    // Reload sessions to update the sidebar
                    loadSessions(currentPage);
                } else {
                    // Handle specific error cases
                    if (response.status === 403) {
                        showErrorMessage('You do not have permission to delete this session.');
                    } else if (response.status === 404) {
                        showErrorMessage('Session not found.');
                    } else {
                        showErrorMessage(data.message || 'Failed to delete session. Please try again.');
                    }
                }
            } catch (error) {
                console.error('Delete session error:', error);
                showErrorMessage('Failed to delete session. Please check your connection and try again.');
            }
        }

        function showSuccessMessage(message) {
            const errorDiv = document.getElementById('errorMessage');
            if (errorDiv) {
                errorDiv.textContent = message;
                errorDiv.style.backgroundColor = '#22c55e';
                errorDiv.style.borderColor = '#16a34a';
                errorDiv.style.color = 'white';
                errorDiv.style.display = 'block';
                
                setTimeout(() => {
                    errorDiv.style.display = 'none';
                }, 3000);
            }
        }

        async function loadSession(sessionId) {
            try {
                // Reset tree path when loading a new session
                currentTreePath = null;
                
                const response = await makeAuthenticatedRequest(`/chatbot/message?session=${sessionId}`, {
                    method: 'GET'
                });

                const data = await response.json();

                if (response.ok) {
                    currentSessionId = sessionId;
                    updateURL();
                    
                    // Store complete session messages for branch navigation
                    const messages = data.data || [];
                    currentSessionMessages = messages;
                    
                    // Calculate the default tree path for the main conversation branch
                    if (messages.length > 0) {
                        currentTreePath = calculateMainTreePath(messages);
                        // Calculated main tree path
                    }
                    
                    displayMessages(messages); // Fix: use data.data instead of data.messages
                    // Update active session in sidebar
                    updateActiveSession(sessionId);
                    // Check if we should block input after loading messages
                    checkIfWaitingForResponse();
                } else {
                    // Check for authentication/authorization errors
                    if (response.status === 403 || response.status === 404) {
                        const errorMessage = data.message || 'Access denied';
                        if (shouldRedirectToLogin(errorMessage)) {
                            localStorage.removeItem('token');
                            window.location.href = '/login';
                            return;
                        }
                    }
                    showErrorMessage(data.message || 'Failed to load session');
                }
            } catch (error) {
                console.error('Load session error:', error);
                showErrorMessage('Failed to load session. Please try again.');
            }
        }

        function displayMessages(messages) {
            const chatMessages = document.getElementById('chatMessages');
            chatMessages.innerHTML = '';

            if (messages.length === 0) {
                chatMessages.innerHTML = `
                    <div class="welcome-message">
                        <h3>Session Loaded!</h3>
                        <p>Continue your conversation or start a new topic.</p>
                    </div>
                `;
                return;
            }

            // Clear conversation branches
            currentConversationBranches = {};

            // Filter messages based on current tree path
            let messagesToDisplay = messages;
            
            if (currentTreePath) {
                const pathIds = currentTreePath.split(',').filter(id => id !== '');
                
                // Show messages that are in the current tree path OR have multiple connections (need navigation)
                messagesToDisplay = messages.filter(msg => {
                    const isInPath = pathIds.includes(msg.id.toString());
                    const hasMultipleConnections = msg.connections > 1;
                    
                    if (isInPath) {
                        return true;
                    } else if (hasMultipleConnections) {
                        // Include parent messages with multiple connections even if not in current path
                        // This ensures branch navigation controls are visible
                        return true;
                    }
                    return false;
                });
            }

            messagesToDisplay.forEach((msg, index) => {
                const messageDiv = addMessageToChat(msg.sender, msg.content, msg.created_at, false, msg);
                
                // Store branch information
                if (msg.connects_to && msg.connections > 0) {
                    currentConversationBranches[msg.id] = {
                        connects_to: msg.connects_to,
                        connections: msg.connections
                    };
                    
                    // Add visual indicator for messages with branches
                    messageDiv.classList.add('has-branches');
                }
            });
            
            // Update tree path display
            updateTreePathDisplay();
        }

        function startNewSession() {
            currentSessionId = null;
            currentTreePath = null;
            currentConversationBranches = {};
            currentSessionMessages = []; // Clear session messages for new session
            document.getElementById('chatMessages').innerHTML = `
                <div class="welcome-message">
                    <h3>New Conversation Started!</h3>
                    <p>What would you like to talk about?</p>
                </div>
            `;
            updateURL();
            updateTreePathDisplay();
            // Clear active session highlighting
            updateActiveSession(null);
        }

        function updateActiveSession(sessionId) {
            // Remove active class from all sessions
            document.querySelectorAll('.session-item').forEach(item => {
                item.classList.remove('active');
            });

            // Add active class to current session
            if (sessionId) {
                const activeSession = document.querySelector(`[data-session-id="${sessionId}"]`);
                if (activeSession) {
                    activeSession.classList.add('active');
                }
            }
        }

        function updateURL() {
            const url = new URL(window.location);
            if (currentSessionId && currentSessionId !== 'guest') {
                url.searchParams.set('session', currentSessionId);
            } else {
                url.searchParams.delete('session');
            }
            window.history.pushState({}, '', url);
        }

        function updatePagination(hasNext, hasPrevious) {
            // Updating pagination controls

            const prevBtn = document.getElementById('prevPage');
            const nextBtn = document.getElementById('nextPage');

            prevBtn.disabled = !hasPrevious;
            nextBtn.disabled = !hasNext;

            document.getElementById('pageInfo').textContent = `Page ${currentPage}`;

            // Button states updated
        }

        function changePage(page) {
            if (page < 1) {
                return;
            }

            // Check if the button should be disabled
            const prevBtn = document.getElementById('prevPage');
            const nextBtn = document.getElementById('nextPage');

            // Don't allow clicking if button is disabled
            if (page < currentPage && prevBtn.disabled) {
                return;
            }
            if (page > currentPage && nextBtn.disabled) {
                return;
            }

            console.log(`Loading sessions for page: ${page}`);
            loadSessions(page);
        }

        function toggleMobileSidebar() {
            const sidebar = document.getElementById('sessionsSidebar');
            sidebar.classList.toggle('mobile-open');
        }

        function logout() {
            localStorage.removeItem('token');
            window.location.href = '/';
        }

        function processCodeBlocks(text) {
            // helper to escape <, > and &
            const escapeHtml = str =>
                str.replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;");

            // 1) Pull out fenced-code blocks into placeholders
            const codeBlocks = [];
            text = text.replace(
                /```(\w+)?\r?\n([\s\S]*?)```/g,
                (_, lang = "text", code) => {
                    const id = codeBlocks.length;
                    codeBlocks.push({ lang, code });
                    return `@@CODE${id}@@`;
                }
            );

            // 2) Escape the rest of the text
            text = escapeHtml(text);

            // 3) Markdown ‚Üí HTML on non-code text
            text = text
                // bold
                .replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>")
                .replace(/__(.*?)__/g, "<strong>$1</strong>")
                // italics (avoid ** conflict)
                .replace(/(^|[^*])\*([^*\n][^*]*?)\*(?!\*)/g, "$1<em>$2</em>")
                .replace(/(^|[^_])_([^_\n][^_]*?)_(?!_)/g, "$1<em>$2</em>")
                // bullets
                .replace(/^\s*[-*]\s+(.+)$/gm, "<li>$1</li>")
                .replace(/(<li>.*<\/li>)+/gs, m => `<ul>${m}</ul>`)
                // finally turn newlines into <br>
                .replace(/\n/g, "<br>");

            // 4) Restore each code block, escaping its interior but leaving its newlines
            codeBlocks.forEach(({ lang, code }, i) => {
                const blockHtml =
                    `<div class="code-block">` +
                    `<div class="code-header">${lang}</div>` +
                    `<pre><code class="language-${lang}">` +
                    escapeHtml(code) +
                    `</code></pre>` +
                    `</div>`;
                text = text.replace(new RegExp(`@@CODE${i}@@`, "g"), blockHtml);
            });

            return text;
        }

        // Input blocking functionality
        function isWaitingForResponse() {
            const chatMessages = document.getElementById('chatMessages');
            const messages = chatMessages.querySelectorAll('.message:not(.typing-indicator)');
            
            if (messages.length === 0) return false;
            
            const lastMessage = messages[messages.length - 1];
            return lastMessage.classList.contains('user-message');
        }

        function setWaitingForResponse(waiting) {
            const messageInput = document.getElementById('messageInput');
            const sendBtn = document.getElementById('sendBtn');
            
            if (waiting) {
                messageInput.disabled = true;
                messageInput.placeholder = "Waiting for response...";
                sendBtn.disabled = true;
                sendBtn.style.opacity = '0.5';
                sendBtn.style.cursor = 'not-allowed';
            } else {
                messageInput.disabled = false;
                messageInput.placeholder = "Type your message here...";
                sendBtn.disabled = false;
                sendBtn.style.opacity = '1';
                sendBtn.style.cursor = 'pointer';
            }
        }

        function checkIfWaitingForResponse() {
            if (isWaitingForResponse()) {
                setWaitingForResponse(true);
            }
        }

        // Action buttons functionality
        function addActionButtonsToMessage(messageDiv, originalMessage) {
            // Check if actions already exist
            if (messageDiv.querySelector('.message-actions')) {
                return;
            }

            const actionsDiv = document.createElement('div');
            actionsDiv.className = 'message-actions';
            actionsDiv.innerHTML = `
                <button class="action-btn delete-btn" onclick="deleteMessage(this)" title="Delete message">üóëÔ∏è</button>
                <button class="action-btn retry-btn" onclick="retryMessage(this)" title="Try again">üîÑ</button>
                <button class="action-btn edit-btn" onclick="editMessage(this)" title="Edit message">‚úèÔ∏è</button>
            `;
            messageDiv.appendChild(actionsDiv);
            messageDiv.dataset.originalMessage = originalMessage;
        }

        function deleteMessage(button) {
            const messageDiv = button.closest('.message');
            if (messageDiv && confirm('Are you sure you want to delete this message?')) {
                messageDiv.remove();
            }
        }

        function retryMessage(button) {
            const messageDiv = button.closest('.message');
            if (messageDiv) {
                const originalMessage = messageDiv.dataset.originalMessage || messageDiv.querySelector('.message-content').textContent;
                // Remove the failed message
                messageDiv.remove();
                // Send the message again
                document.getElementById('messageInput').value = originalMessage;
                sendMessage();
            }
        }

        function editMessage(button) {
            const messageDiv = button.closest('.message');
            if (messageDiv) {
                const originalMessage = messageDiv.dataset.originalMessage || messageDiv.querySelector('.message-content').textContent;
                // Remove the failed message
                messageDiv.remove();
                // Put the message back in the input for editing
                document.getElementById('messageInput').value = originalMessage;
                document.getElementById('messageInput').focus();
                adjustTextareaHeight();
                // Unblock input in case it was blocked
                setWaitingForResponse(false);
            }
        }

        // ChatGPT-Style Branching Functions
        function addUserMessageEditControls(messageDiv, messageData, originalMessage) {
            if (!messageData || !messageData.id) return null;
            
            const controlsDiv = document.createElement('div');
            controlsDiv.className = 'user-edit-controls';
            
            controlsDiv.innerHTML = `
                <button class="edit-message-btn" onclick="editUserMessage('${messageData.id}', '${originalMessage.replace(/'/g, "\\'")}')">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                        <path d="m18.5 2.5 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                    </svg>
                </button>
            `;
            
            return controlsDiv;
        }
        
        function addBranchNavigationControls(messageDiv, messageData) {
            if (!messageData || !messageData.connects_to || messageData.connections <= 1) {
                return null;
            }
            
            const navigationDiv = document.createElement('div');
            navigationDiv.className = 'branch-navigation-controls';
            
            // Get current branch index based on parent bot message branches
            const branchIds = messageData.connects_to.split(',');
            const parentBotId = messageData.parent_bot_id || messageData.id; // fallback for compatibility
            const currentBranchIndex = getCurrentBranchIndex(parentBotId, branchIds);
            
            navigationDiv.innerHTML = `
                <div class="branch-nav-display">
                    <button class="nav-arrow nav-left" onclick="navigateToPreviousBranch('${parentBotId}')" ${currentBranchIndex === 0 ? 'disabled' : ''}>
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="15,18 9,12 15,6"></polyline>
                        </svg>
                    </button>
                    <span class="branch-counter">${currentBranchIndex + 1}/${branchIds.length}</span>
                    <button class="nav-arrow nav-right" onclick="navigateToNextBranch('${parentBotId}')" ${currentBranchIndex === branchIds.length - 1 ? 'disabled' : ''}>
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="9,18 15,12 9,6"></polyline>
                        </svg>
                    </button>
                </div>
            `;
            
            // Created branch navigation for message
            return navigationDiv;
        }
        
        async function editUserMessage(messageId, originalMessage) {
            // Show edit modal or inline editor
            const newMessage = prompt('Edit your message:', originalMessage);
            if (!newMessage || !newMessage.trim() || newMessage.trim() === originalMessage) {
                return;
            }
            
            if (!currentSessionId || isGuest) {
                showErrorMessage('Editing is only available for authenticated users in saved sessions.');
                return;
            }
            
            // Block input while processing
            setWaitingForResponse(true);
            
            try {
                // If currentSessionMessages is empty, wait a bit for it to be populated
                if (currentSessionMessages.length === 0) {
                    // Waiting for session messages to be populated...
                    await new Promise(resolve => setTimeout(resolve, 500)); // Wait 500ms
                }
                
                // Find the parent message (the bot message that this user message responded to)
                const parentMessageId = await getParentBotMessage(messageId);
                // Edit workflow initiated
                // Current session messages available
                
                if (!parentMessageId) {
                    console.error(`Could not find parent message for user message ${messageId}`);
                    showErrorMessage('Cannot create branch: Unable to find parent message. Please refresh the page and try again.');
                    return;
                }
                
                const response = await makeAuthenticatedRequest(`/chatbot?session=${currentSessionId}`, {
                    method: 'POST',
                    body: JSON.stringify({ 
                        message: newMessage.trim(),
                        parent_message_id: parentMessageId
                    })
                });
                
                const data = await response.json();
                
                if (response.ok && data.messages) {
                    // Get the new user message ID from the response
                    const newUserMessage = data.messages.find(m => m.sender === 'user');
                    const newBotMessage = data.messages.find(m => m.sender === 'bot');
                    
                    if (newUserMessage && newBotMessage) {
                        // Update stored session messages with the new branch messages
                        if (data.messages) {
                            data.messages.forEach(newMsg => {
                                // Check if message already exists (avoid duplicates)
                                const existingIndex = currentSessionMessages.findIndex(msg => 
                                    (msg.id || msg.message_id) === (newMsg.id || newMsg.message_id)
                                );
                                if (existingIndex === -1) {
                                    currentSessionMessages.push(newMsg);
                                } else {
                                    // Update existing message with new data
                                    currentSessionMessages[existingIndex] = newMsg;
                                }
                            });
                            // Updated session messages after branch creation
                        }
                        
                        // Update the parent bot message's connection count in currentSessionMessages
                        const parentBotIndex = currentSessionMessages.findIndex(msg => 
                            (msg.id || msg.message_id).toString() === parentMessageId.toString()
                        );
                        if (parentBotIndex !== -1) {
                            const parentMsg = currentSessionMessages[parentBotIndex];
                            
                            // Update connects_to to include the new user message
                            const currentConnectsTo = parentMsg.connects_to || '';
                            const connectsToArray = currentConnectsTo ? currentConnectsTo.split(',').filter(id => id !== '') : [];
                            
                            if (!connectsToArray.includes(newUserMessage.id.toString())) {
                                connectsToArray.push(newUserMessage.id.toString());
                                parentMsg.connects_to = connectsToArray.join(',');
                                parentMsg.connections = connectsToArray.length;
                                // Updated parent bot message structure
                            }
                        }
                        
                        // Calculate and navigate to the new branch path
                        const newTreePath = await calculateNewBranchTreePath(parentMessageId, newUserMessage.id, newBotMessage.id);
                        
                        // Navigate to the new branch using the complete session data
                        currentTreePath = newTreePath;
                        updateURL();
                        
                        // Get all messages from the current session data and display the branch
                        const allMessages = getCurrentSessionMessages();
                        displayMessages(allMessages);
                        
                        // AFTER displaying messages, update the DOM to ensure branch navigation controls appear
                        setTimeout(() => {
                            const parentBotIndex = currentSessionMessages.findIndex(msg => 
                                (msg.id || msg.message_id).toString() === parentMessageId.toString()
                            );
                            if (parentBotIndex !== -1) {
                                const parentMsg = currentSessionMessages[parentBotIndex];
                                const parentMessageDiv = document.querySelector(`[data-message-id="${parentMessageId}"]`);
                                if (parentMessageDiv && parentMsg.connections > 1) {
                                    // Update the data attributes
                                    parentMessageDiv.dataset.connectsTo = parentMsg.connects_to;
                                    parentMessageDiv.dataset.connections = parentMsg.connections;
                                    
                                    // Since we moved navigation to user messages, find the user message that connects from this bot message
                                    // and add navigation controls to it
                                    const userMessageWithBranches = currentSessionMessages.find(msg => 
                                        msg.sender === 'user' && msg.connected_from === parentMessageId.toString()
                                    );
                                    
                                    if (userMessageWithBranches) {
                                        const userMessageDiv = document.querySelector(`[data-message-id="${userMessageWithBranches.id}"]`);
                                        if (userMessageDiv) {
                                            // Remove existing navigation controls if any
                                            const existingNav = userMessageDiv.querySelector('.branch-navigation-controls');
                                            if (existingNav) {
                                                existingNav.remove();
                                            }
                                            
                                            // Add new navigation controls to the user message
                                            const navigationDiv = addBranchNavigationControls(userMessageDiv, {
                                                id: userMessageWithBranches.id,
                                                connects_to: parentMsg.connects_to,
                                                connections: parentMsg.connections,
                                                parent_bot_id: parentMsg.id
                                            });
                                            if (navigationDiv) {
                                                userMessageDiv.appendChild(navigationDiv);
                                                // Added branch navigation controls to user message after DOM update
                                            }
                                        }
                                    }
                                }
                            }
                        }, 100); // Small delay to ensure DOM is fully rendered
                        
                        showSuccessMessage('Message edited and new branch created! Showing new branch.');
                    } else {
                        // Fallback: reload the entire session
                        await loadSession(currentSessionId);
                        showSuccessMessage('Message edited and new branch created!');
                    }
                } else {
                    showErrorMessage(data.message || 'Failed to edit message');
                }
            } catch (error) {
                console.error('Edit message error:', error);
                showErrorMessage('Failed to edit message. Please try again.');
            } finally {
                setWaitingForResponse(false);
            }
        }
        
        async function getParentBotMessage(userMessageId) {
            // getParentBotMessage called for user message
            
            // First try to get from stored session messages
            const allMessages = getCurrentSessionMessages();
            console.log(`  - Found ${allMessages.length} stored session messages`);
            
            if (allMessages && allMessages.length > 0) {
                const userMessage = allMessages.find(msg => {
                    const msgId = msg.id || msg.message_id;
                    return msgId && msgId.toString() === userMessageId.toString();
                });
                if (userMessage) {
                    console.log(`  - Found user message in session data:`, userMessage);
                    if (userMessage.connected_from) {
                        console.log(`  - Found parent from session data: ${userMessage.connected_from} for user message ${userMessageId}`);
                        return userMessage.connected_from;
                    } else {
                        console.log(`  - User message has no connected_from field`);
                    }
                } else {
                    console.log(`  - User message ${userMessageId} not found in session data`);
                    console.log(`  - Available message IDs:`, allMessages.map(m => m.id || m.message_id));
                }
            } else {
                console.log(`  - No stored session messages available`);
            }
            
            // Fallback to DOM data
            const messageDiv = document.querySelector(`[data-message-id="${userMessageId}"]`);
            if (messageDiv) {
                console.log(`  - Found parent from DOM: ${messageDiv.dataset.connectedFrom} for user message ${userMessageId}`);
                return messageDiv.dataset.connectedFrom;
            }
            
            console.log(`  - No parent found for user message ${userMessageId}`);
            return null;
        }
        
        function getCurrentSessionMessages() {
            return currentSessionMessages || [];
        }
        
        async function calculateNewBranchTreePath(parentBotId, newUserId, newBotId) {
            // Build the full tree path from the root of the conversation to the new branch
            try {
                // First try to use the stored session messages
                let messages = getCurrentSessionMessages();
                
                // If we don't have enough messages stored, fetch from server
                if (messages.length === 0) {
                    console.log('No stored messages, fetching from server for tree path calculation');
                    const response = await makeAuthenticatedRequest(`/chatbot/message?session=${currentSessionId}`, {
                        method: 'GET'
                    });
                    
                    if (!response.ok) {
                        console.error('Failed to get session messages for tree path calculation');
                        return `,${parentBotId},${newUserId},${newBotId}`;
                    }
                    
                    const data = await response.json();
                    messages = data.data || [];
                } else {
                    // Using stored session messages for tree path calculation
                }
                
                // Create a map of message ID to message for easy lookup
                const messageMap = {};
                messages.forEach(msg => {
                    messageMap[msg.id] = msg;
                });
                
                // Build the full path by tracing backward from parent to root, then forward
                const pathIds = [''];  // Start with empty string for root
                
                // Tracing path to parent bot
                
                // Simple backward tracing from parentBotId to root
                const backwardPath = [];
                let currentId = parentBotId;
                
                while (currentId && messageMap[currentId]) {
                    const msg = messageMap[currentId];
                    backwardPath.unshift(currentId); // Add to beginning
                    console.log(`  ‚Üê ${currentId} (${msg.sender}) from ${msg.connected_from}`);
                    
                    if (msg.connected_from === 'main') {
                        break;
                    }
                    currentId = msg.connected_from;
                }
                
                // Add the traced path
                pathIds.push(...backwardPath);
                
                // Add the new branch messages to the path
                pathIds.push(newUserId, newBotId);
                
                const fullTreePath = pathIds.join(',');
                console.log('Calculated new branch tree path:', fullTreePath);
                return fullTreePath;
                
            } catch (error) {
                console.error('Error calculating tree path:', error);
                // Fallback to simple path
                return `${parentBotId},${newUserId},${newBotId}`;
            }
        }
        
        async function loadSessionWithTreePath(sessionId, treePath) {
            try {
                console.log('Loading session with tree path:', sessionId, treePath);
                
                const response = await makeAuthenticatedRequest(`/chatbot/message?session=${sessionId}&tree=${encodeURIComponent(treePath)}`, {
                    method: 'GET'
                });

                const data = await response.json();

                if (response.ok) {
                    currentSessionId = sessionId;
                    currentTreePath = treePath;
                    updateURL();
                    displayMessages(data.data || []);
                    updateActiveSession(sessionId);
                    checkIfWaitingForResponse();
                    console.log('Successfully loaded session with tree path');
                } else {
                    console.error('Failed to load session with tree path:', data);
                    // Fallback to loading without tree path
                    await loadSession(sessionId);
                }
            } catch (error) {
                console.error('Load session with tree path error:', error);
                // Fallback to loading without tree path
                await loadSession(sessionId);
            }
        }
        
        function calculateMainTreePath(messages) {
            // Build the main conversation path by following connected_from relationships
            const path = [''];
            
            let currentMessageId = 'main';
            // Calculating main tree path
            
            while (true) {
                // Find the message connected FROM the current message
                const nextMessage = messages.find(msg => msg.connected_from === currentMessageId.toString());
                if (!nextMessage) {
                    console.log(`  No more messages connected from ${currentMessageId}`);
                    break;
                }
                
                // Add this message to the path
                path.push(nextMessage.id.toString());
                console.log(`  Added message ${nextMessage.id} (${nextMessage.sender}) to path`);
                
                // Move to this message and continue looking for what connects FROM it
                currentMessageId = nextMessage.id.toString();
                
                // If this message has multiple branches, we need to choose one for the main path
                if (nextMessage.connects_to) {
                    const branchIds = nextMessage.connects_to.split(',').filter(id => id !== '');
                    if (branchIds.length > 1) {
                        console.log(`  Message ${nextMessage.id} has ${branchIds.length} branches: ${branchIds.join(', ')}`);
                        console.log(`  Continuing main path with first connection`);
                        // Don't change currentMessageId here - let the loop find the connected message
                    }
                }
            }
            
            const treePath = path.join(',');
            // Main tree path calculated
            return treePath;
        }

        function getCurrentBranchIndex(botMessageId, branchIds) {
            // getCurrentBranchIndex for bot message
            console.log(`  - Current tree path: ${currentTreePath}`);
            
            // Determine which branch we're currently viewing based on the tree path
            if (currentTreePath) {
                const pathIds = currentTreePath.split(',');
                console.log(`  - Tree path IDs: ${pathIds.join(', ')}`);
                
                // Look for any of the branch IDs (user message IDs) in our current path
                for (let i = 0; i < branchIds.length; i++) {
                    if (pathIds.includes(branchIds[i])) {
                        console.log(`  - Found branch ${branchIds[i]} in path at index ${i}`);
                        return i;
                    }
                }
            }
            
            // If no tree path or no match found, check which user message branch is currently visible
            // by looking for the first visible user message that connects from this bot message
            const allMessages = getCurrentSessionMessages();
            const visibleUserMessage = allMessages.find(msg => 
                msg.sender === 'user' && 
                msg.connected_from === botMessageId.toString() &&
                document.querySelector(`[data-message-id="${msg.id}"]`)
            );
            
            if (visibleUserMessage) {
                const index = branchIds.indexOf(visibleUserMessage.id.toString());
                if (index !== -1) {
                    console.log(`  - Found visible user message ${visibleUserMessage.id} at branch index ${index}`);
                    return index;
                }
            }
            
            console.log(`  - Defaulting to branch index 0`);
            return 0; // Default to first branch
        }
        
        async function navigateToPreviousBranch(botMessageId) {
            // Find the bot message in the session data to get its branches
            const allMessages = getCurrentSessionMessages();
            const botMessage = allMessages.find(msg => msg.id.toString() === botMessageId.toString());
            
            if (!botMessage || !botMessage.connects_to) return;
            
            const branchIds = botMessage.connects_to.split(',');
            const currentIndex = getCurrentBranchIndex(botMessageId, branchIds);
            
            if (currentIndex > 0) {
                const targetBranchId = branchIds[currentIndex - 1];
                await navigateToBranch(targetBranchId);
            }
        }
        
        async function navigateToNextBranch(botMessageId) {
            // Find the bot message in the session data to get its branches
            const allMessages = getCurrentSessionMessages();
            const botMessage = allMessages.find(msg => msg.id.toString() === botMessageId.toString());
            
            if (!botMessage || !botMessage.connects_to) return;
            
            const branchIds = botMessage.connects_to.split(',');
            const currentIndex = getCurrentBranchIndex(botMessageId, branchIds);
            
            if (currentIndex < branchIds.length - 1) {
                const targetBranchId = branchIds[currentIndex + 1];
                await navigateToBranch(targetBranchId);
            }
        }
        
        async function navigateToBranch(branchId) {
            if (!currentSessionId) return;
            
            try {
                console.log(`Navigating to branch ${branchId}`);
                
                // Instead of making a server request, calculate the new tree path
                // and re-display messages with the updated path
                
                // Get all messages from the current session (they should already be loaded)
                const response = await makeAuthenticatedRequest(`/chatbot/message?session=${currentSessionId}`, {
                    method: 'GET'
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    const allMessages = data.data || [];
                    
                    // Calculate new tree path that includes the target branch
                    const newTreePath = calculateTreePathToBranch(allMessages, branchId);
                    // New tree path calculated for branch
                    
                    currentTreePath = newTreePath;
                    
                    // Re-enable filtering and display messages for this tree path
                    displayMessagesWithFiltering(allMessages);
                    updateTreePathDisplay();
                } else {
                    showErrorMessage(data.message || 'Failed to navigate to branch');
                }
            } catch (error) {
                console.error('Navigate branch error:', error);
                showErrorMessage('Failed to navigate to branch. Please try again.');
            }
        }
        
        function calculateTreePathToBranch(messages, targetBranchId) {
            // Find the target message
            const targetMessage = messages.find(msg => msg.id.toString() === targetBranchId);
            if (!targetMessage) {
                console.error(`Target message ${targetBranchId} not found`);
                return '';
            }
            
            console.log(`Building tree path to branch ${targetBranchId}`);
            
            // Build path backwards from target to root
            const pathIds = [''];
            const reversePath = [];
            let currentId = targetMessage.id;
            
            // Trace back to root to get the leading context
            while (currentId) {
                const msg = messages.find(m => m.id === currentId);
                if (!msg) break;
                
                reversePath.unshift(currentId);
                console.log(`  Added ${currentId} (${msg.sender}) to reverse path`);
                
                if (msg.connected_from === 'main') {
                    break;
                }
                currentId = parseInt(msg.connected_from);
            }
            
            // Add the backward path to our main path
            pathIds.push(...reversePath);
            
            // Now continue forward from the target message to get the full branch conversation
            let currentMessage = targetMessage;
            while (currentMessage && currentMessage.connects_to) {
                const nextIds = currentMessage.connects_to.split(',').filter(id => id !== '');
                if (nextIds.length > 0) {
                    // Follow the first connection (for now, could be enhanced to follow all)
                    const nextId = parseInt(nextIds[0]);
                    const nextMessage = messages.find(m => m.id === nextId);
                    if (nextMessage) {
                        pathIds.push(nextId.toString());
                        console.log(`  Extended path with ${nextId} (${nextMessage.sender})`);
                        currentMessage = nextMessage;
                    } else {
                        break;
                    }
                } else {
                    break;
                }
            }
            
            const finalPath = pathIds.join(',');
            console.log(`Final branch path: ${finalPath}`);
            return finalPath;
        }
        
        function displayMessagesWithFiltering(messages) {
            const chatMessages = document.getElementById('chatMessages');
            chatMessages.innerHTML = '';

            if (messages.length === 0) {
                chatMessages.innerHTML = `
                    <div class="welcome-message">
                        <h3>Session Loaded! üëã</h3>
                        <p>Continue your conversation or start a new topic.</p>
                    </div>
                `;
                return;
            }

            // Clear conversation branches
            currentConversationBranches = {};

            // displayMessagesWithFiltering called
            // Current tree path logging

            // Filter messages based on current tree path
            let messagesToDisplay = messages;
            
            if (currentTreePath) {
                // Filtering messages by tree path
                const pathIds = currentTreePath.split(',').filter(id => id !== '');
                
                // Only show messages that are in the current tree path
                messagesToDisplay = messages.filter(msg => {
                    const isInPath = pathIds.includes(msg.id.toString());
                    if (isInPath) {
                        // Message is in path
                    }
                    return isInPath;
                });
                
                // Displaying filtered messages
            } else {
                // No tree path set, displaying all messages
            }

            messagesToDisplay.forEach((msg, index) => {
                // Adding message to chat
                const messageDiv = addMessageToChat(msg.sender, msg.content, msg.created_at, false, msg);
                
                // Store branch information
                if (msg.connects_to && msg.connections > 0) {
                    currentConversationBranches[msg.id] = {
                        connects_to: msg.connects_to,
                        connections: msg.connections
                    };
                    
                    // Add visual indicator for messages with branches
                    messageDiv.classList.add('has-branches');
                }
            });
            
            // displayMessagesWithFiltering completed
            
            // Update tree path display
            updateTreePathDisplay();
        }
        
        function updateBranchStructure(messages) {
            messages.forEach(msg => {
                if (msg.connects_to && msg.connections > 0) {
                    currentConversationBranches[msg.id] = {
                        connects_to: msg.connects_to,
                        connections: msg.connections
                    };
                }
            });
        }
        
        function updateTreePathDisplay() {
            // Disabled - user requested no branch display at the top
            // Branch navigation is handled through message-level controls instead
            return;
        }
        
        async function returnToMainBranch() {
            if (!currentSessionId) return;
            
            try {
                const response = await makeAuthenticatedRequest(`/chatbot/message?session=${currentSessionId}`, {
                    method: 'GET'
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    currentTreePath = null;
                    displayMessages(data.data || []);
                    updateTreePathDisplay();
                } else {
                    showErrorMessage(data.message || 'Failed to return to main branch');
                }
            } catch (error) {
                console.error('Return to main branch error:', error);
                showErrorMessage('Failed to return to main branch. Please try again.');
            }
        }
        
        function getLastBotMessageFromCurrentBranch() {
            const messages = document.querySelectorAll('.message.bot-message');
            if (messages.length === 0) return null;
            
            const lastBotMessage = messages[messages.length - 1];
            const messageId = lastBotMessage.dataset.messageId;
            
            if (messageId) {
                return { id: messageId };
            }
            
            return null;
        }

        function showSuccessMessage(message) {
            // Remove any existing notifications
            const existingNotification = document.querySelector('.success-notification');
            if (existingNotification) {
                existingNotification.remove();
            }

            // Create success notification
            const successDiv = document.createElement('div');
            successDiv.className = 'success-notification';
            successDiv.innerHTML = `
                <div class="success-content">
                    <span class="success-icon">‚úÖ</span>
                    <span class="success-text">${message}</span>
                    <button class="success-close" onclick="this.parentElement.parentElement.remove()">√ó</button>
                </div>
            `;

            // Insert at the top of chat container
            const chatContainer = document.querySelector('.chat-container');
            chatContainer.insertBefore(successDiv, chatContainer.firstChild);

            // Auto-hide after 3 seconds
            setTimeout(() => {
                if (successDiv.parentNode) {
                    successDiv.remove();
                }
            }, 3000);
        }
    </script>
</body>

</html>
