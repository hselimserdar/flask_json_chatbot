<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <title>HSS GPT</title>
    <link rel="icon" type="image/png" href="{{ url_for('static', filename='icons/50px-logo.png') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}?v=20250814151">
    <style>
        /* Force scrollbar styles with inline CSS for immediate effect */
        .chat-messages::-webkit-scrollbar,
        #chatMessages::-webkit-scrollbar,
        pre::-webkit-scrollbar,
        code::-webkit-scrollbar,
        .hljs::-webkit-scrollbar {
            width: 12px !important;
            height: 12px !important;
        }
        
        .chat-messages::-webkit-scrollbar-track,
        #chatMessages::-webkit-scrollbar-track,
        pre::-webkit-scrollbar-track,
        code::-webkit-scrollbar-track,
        .hljs::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3) !important;
            border-radius: 6px !important;
            border: 1px solid rgba(0, 0, 0, 0.1) !important;
        }
        
        .chat-messages::-webkit-scrollbar-thumb,
        #chatMessages::-webkit-scrollbar-thumb,
        pre::-webkit-scrollbar-thumb,
        code::-webkit-scrollbar-thumb,
        .hljs::-webkit-scrollbar-thumb {
            background: linear-gradient(45deg, #c4c4c4 0%, #d1d1d1 50%, #c4c4c4 100%) !important;
            border-radius: 6px !important;
            border: 1px solid #b0b0b0 !important;
            box-shadow: inset 0 0 1px rgba(255, 255, 255, 0.3) !important;
        }

        .chat-messages::-webkit-scrollbar-thumb:hover,
        #chatMessages::-webkit-scrollbar-thumb:hover,
        pre::-webkit-scrollbar-thumb:hover,
        code::-webkit-scrollbar-thumb:hover,
        .hljs::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(45deg, #d1d1d1 0%, #e0e0e0 50%, #d1d1d1 100%) !important;
        }

        /* Copy button contrast fix */
        .message-copy-btn {
            color: #000000 !important;
            opacity: 0.8 !important;
        }

        /* Mobile horizontal scroll fix */
        @media (max-width: 768px) {
            html, body {
                overflow-x: hidden !important;
                max-width: 100vw !important;
            }
            
            .chat-container, .chat-messages, #chatMessages {
                overflow-x: hidden !important;
                max-width: 100% !important;
            }
            
            .user-message, .bot-message {
                max-width: calc(100% - 1rem) !important;
                word-wrap: break-word !important;
                overflow-wrap: break-word !important;
            }
            
            .bot-message {
                margin-right: 1rem !important;
            }
            
            .message-content {
                max-width: 100% !important;
                word-break: break-word !important;
            }
        }

        /* Session edit controls - cache busting */
        .session-actions {
            display: flex !important;
            align-items: center !important;
            gap: 0.25rem !important;
            margin-left: 0.5rem !important;
            flex-shrink: 0 !important;
        }

        .session-edit-btn {
            background: none !important;
            border: none !important;
            cursor: pointer !important;
            padding: 0.25rem !important;
            border-radius: 4px !important;
            opacity: 0 !important;
            transition: all 0.2s ease !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            color: #6b7280 !important;
        }

        .session-edit-btn:hover {
            background-color: rgba(59, 130, 246, 0.1) !important;
            color: #3b82f6 !important;
        }

        .session-item:hover .session-edit-btn {
            opacity: 1 !important;
        }

        .session-item.active .session-edit-btn {
            color: rgba(255, 255, 255, 0.8) !important;
        }

        .session-item.active .session-edit-btn:hover {
            background-color: rgba(255, 255, 255, 0.1) !important;
            color: white !important;
        }

        /* Success notification */
        .success-notification {
            position: fixed !important;
            top: 1rem !important;
            right: 1rem !important;
            z-index: 9999 !important;
            background: #10b981 !important;
            color: white !important;
            padding: 1rem !important;
            border-radius: 8px !important;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15) !important;
            max-width: 400px !important;
        }

        .success-content {
            display: flex !important;
            align-items: center !important;
            gap: 0.5rem !important;
        }

        .success-close {
            background: none !important;
            border: none !important;
            color: white !important;
            cursor: pointer !important;
            font-size: 1.25rem !important;
            margin-left: auto !important;
        }

        /* Mobile session edit controls */
        @media (max-width: 768px) {
            .session-edit-btn {
                opacity: 1 !important;
                width: 36px !important;
                height: 36px !important;
                background-color: rgba(107, 114, 128, 0.1) !important;
                border: 1px solid rgba(107, 114, 128, 0.2) !important;
                border-radius: 8px !important;
            }
            
            .session-edit-btn:active {
                transform: scale(0.95) !important;
            }
        }
    </style>
    <!-- pick a style you like; here's GitHub-Dark -->
    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
    <!-- load any extras if you want, but core already includes most langs -->
    <!-- Arduino language definition -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/arduino.min.js"></script>
    <script>hljs.highlightAll();</script>

</head>

<body>
    <div class="chat-container">
        <header class="chat-header">
            <div class="header-left">
                <button id="mobileMenuBtn" class="mobile-menu-btn">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="3" y1="6" x2="21" y2="6"></line>
                        <line x1="3" y1="12" x2="21" y2="12"></line>
                        <line x1="3" y1="18" x2="21" y2="18"></line>
                    </svg>
                </button>
                <a href="{{ url_for('home') }}" class="logo-link">
                    <img src="{{ url_for('static', filename='icons/50px-logo.png') }}" alt="HSS GPT Logo" class="chat-logo">
                </a>
                <h1>HSS GPT</h1>
                <span id="userInfo" class="user-info"></span>
            </div>
            <div class="header-right">
                <button id="newSessionBtn" class="btn btn-secondary">New Chat</button>
                <button id="logoutBtn" class="btn btn-outline">Logout</button>
            </div>
        </header>

        <div class="chat-layout">
            <aside id="sessionsSidebar" class="sessions-sidebar open">
                <div class="sidebar-header">
                    <h3>Your Sessions</h3>
                </div>
                <div id="sessionsList" class="sessions-list">
                    <!-- Sessions will be loaded here -->
                </div>
            </aside>

            <main class="chat-main">
                <div id="chatMessages" class="chat-messages">
                    <div class="welcome-message">
                        <h3>Welcome to HSS GPT! 👋</h3>
                        <p>Start a conversation by typing a message below.</p>
                    </div>
                </div>

                <div class="chat-input-container">
                    <div class="input-wrapper">
                        <textarea id="messageInput" placeholder="Type your message here..." rows="1"></textarea>
                        <button id="sendBtn" class="send-btn">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2">
                                <line x1="22" y1="2" x2="11" y2="13"></line>
                                <polygon points="22,2 15,22 11,13 2,9"></polygon>
                            </svg>
                        </button>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <script>
        let currentSessionId = null;
        let currentPage = 1;
        let hasMoreSessions = true;
        let isLoadingSessions = false;
        let isGuest = false;
        let currentTreePath = null;
        let currentConversationBranches = {};  // Store branch structure
        let currentSessionMessages = [];  // Store complete session messages for branch navigation
        let isTypingIndicatorActive = false;  // Track typing indicator state

        // Check authentication on page load
        window.addEventListener('load', function () {
            const token = localStorage.getItem('token');
            if (!token) {
                // Check if this is guest mode
                const urlParams = new URLSearchParams(window.location.search);
                if (urlParams.get('mode') === 'guest') {
                    isGuest = true;
                    currentSessionId = 'guest';
                    document.getElementById('userInfo').textContent = 'Guest User';
                    document.getElementById('newSessionBtn').style.display = 'none';
                    document.getElementById('mobileMenuBtn').style.display = 'none';
                    // Hide sessions sidebar for guest users
                    document.getElementById('sessionsSidebar').style.display = 'none';
                    document.querySelector('.chat-main').classList.remove('with-sidebar');
                } else {
                    window.location.href = '/login';
                    return;
                }
            } else {
                // Verify token and get user info
                verifyToken();
                // Check for session ID in URL parameters
                const urlParams = new URLSearchParams(window.location.search);
                const sessionFromUrl = urlParams.get('session');
                if (sessionFromUrl) {
                    currentSessionId = sessionFromUrl;
                }
                // Reset state and load sessions immediately for authenticated users
                resetSessionsState();
                loadSessions(1);
                // Mark chat main as having sidebar
                document.querySelector('.chat-main').classList.add('with-sidebar');
            }

            setupEventListeners();
            adjustTextareaHeight();
            checkIfWaitingForResponse();
        });

        async function verifyToken() {
            const token = localStorage.getItem('token');
            if (!token) {
                console.error('No token found in localStorage');
                localStorage.removeItem('token');
                window.location.href = '/login';
                return;
            }
            
            try {
                const response = await fetch('/verify-token', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();

                if (response.ok && data.valid) {
                    // Token is valid, update user info with username
                    const userInfoElement = document.getElementById('userInfo');
                    userInfoElement.textContent = `Welcome, ${data.username}`;
                    userInfoElement.title = `Token expires in ${data.time_remaining_minutes} minutes (${data.remaining_percentage}% remaining)`;
                    
                    console.log('Token verification successful:', {
                        username: data.username,
                        expires_at: data.expires_at,
                        time_remaining_minutes: data.time_remaining_minutes,
                        remaining_percentage: data.remaining_percentage,
                        needs_refresh: data.needs_refresh
                    });
                    
                    // Check if token needs refresh (less than 20% lifetime remaining)
                    if (data.needs_refresh) {
                        console.log(`Token has ${data.remaining_percentage}% remaining, refreshing automatically...`);
                        await automaticTokenRefresh();
                    } else {
                        // Set up token expiration warning
                        setupTokenExpirationWarning(data.time_remaining_seconds);
                    }
                    
                } else {
                    // Token is invalid or expired
                    console.error('Token verification failed:', data.message);
                    
                    // Show error message to user
                    if (data.message === 'Token expired') {
                        showErrorMessage('Your session has expired. Please log in again.');
                    } else {
                        showErrorMessage('Authentication failed. Please log in again.');
                    }
                    
                    // Clear invalid token and redirect
                    localStorage.removeItem('token');
                    setTimeout(() => {
                        window.location.href = '/login';
                    }, 2000);
                }
            } catch (error) {
                console.error('Token verification request failed:', error);
                
                // Network error - could be temporary, show warning but don't immediately redirect
                showErrorMessage('Unable to verify authentication. Please check your connection.');
                
                // Still set a fallback display name
                document.getElementById('userInfo').textContent = 'Authenticated User (Unverified)';
                
                // Set up retry mechanism
                setTimeout(() => {
                    verifyToken(); // Retry verification after 30 seconds
                }, 30000);
            }
        }

        async function automaticTokenRefresh() {
            try {
                const currentToken = localStorage.getItem('token');
                const response = await fetch('/refresh-token', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${currentToken}`,
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();

                if (response.ok && data.token) {
                    // Update token in localStorage
                    localStorage.setItem('token', data.token);
                    
                    console.log('Token refreshed automatically:', {
                        username: data.username,
                        expires_at: data.expires_at,
                        message: data.message
                    });
                    
                    // Show success notification
                    showTokenRefreshNotification();
                    
                    // Re-verify with new token to get updated timing info
                    setTimeout(() => {
                        verifyToken();
                    }, 1000);
                    
                } else {
                    console.error('Automatic token refresh failed:', data.message);
                    
                    if (data.message.includes('expired too long ago')) {
                        showErrorMessage('Session expired. Please log in again.');
                        localStorage.removeItem('token');
                        setTimeout(() => {
                            window.location.href = '/login';
                        }, 2000);
                    } else {
                        showErrorMessage('Unable to refresh session. Please log in again.');
                        setTimeout(() => {
                            localStorage.removeItem('token');
                            window.location.href = '/login';
                        }, 3000);
                    }
                }
            } catch (error) {
                console.error('Automatic token refresh error:', error);
                showErrorMessage('Network error during session refresh. Please check your connection.');
            }
        }

        function showTokenRefreshNotification() {
            const notificationDiv = document.createElement('div');
            notificationDiv.className = 'token-refresh-notification';
            notificationDiv.innerHTML = `
                <div class="refresh-content">
                    <span class="refresh-icon">🔄</span>
                    <span class="refresh-text">Session refreshed automatically</span>
                    <button class="refresh-close" onclick="this.parentElement.parentElement.remove()">×</button>
                </div>
            `;

            // Insert at the top of chat container
            const chatContainer = document.querySelector('.chat-container');
            chatContainer.insertBefore(notificationDiv, chatContainer.firstChild);

            // Auto-hide after 3 seconds
            setTimeout(() => {
                if (notificationDiv.parentNode) {
                    notificationDiv.remove();
                }
            }, 3000);
        }

        // Enhanced request wrapper that checks token status before every request
        async function makeAuthenticatedRequest(url, options = {}) {
            const token = localStorage.getItem('token');
            if (!token) {
                throw new Error('No authentication token available');
            }

            // Check token status before making the request
            const tokenCheckResponse = await fetch('/verify-token', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json'
                }
            });

            if (tokenCheckResponse.ok) {
                const tokenData = await tokenCheckResponse.json();
                
                // If token needs refresh, do it before the actual request
                if (tokenData.needs_refresh) {
                    console.log(`Token needs refresh before request to ${url}, refreshing...`);
                    await automaticTokenRefresh();
                }
            }

            // Make the actual request with current token
            const currentToken = localStorage.getItem('token');
            const requestOptions = {
                ...options,
                headers: {
                    ...options.headers,
                    'Authorization': `Bearer ${currentToken}`,
                    'Content-Type': 'application/json'
                }
            };

            return fetch(url, requestOptions);
        }

        function setupTokenExpirationWarning(timeRemainingSeconds) {
            // Clear any existing warning timers
            if (window.tokenWarningTimer) {
                clearTimeout(window.tokenWarningTimer);
            }
            if (window.tokenExpirationTimer) {
                clearTimeout(window.tokenExpirationTimer);
            }
            
            // Show warning 5 minutes before expiration
            const warningTime = Math.max(0, (timeRemainingSeconds - 300) * 1000); // 5 minutes = 300 seconds
            
            if (warningTime > 0) {
                window.tokenWarningTimer = setTimeout(() => {
                    showTokenExpirationWarning();
                }, warningTime);
            } else if (timeRemainingSeconds > 60) {
                // If less than 5 minutes remaining, show warning immediately
                showTokenExpirationWarning();
            }
            
            // Auto-logout when token expires
            window.tokenExpirationTimer = setTimeout(() => {
                showErrorMessage('Your session has expired. Redirecting to login...');
                localStorage.removeItem('token');
                setTimeout(() => {
                    window.location.href = '/login';
                }, 2000);
            }, timeRemainingSeconds * 1000);
        }

        function showTokenExpirationWarning() {
            const warningDiv = document.createElement('div');
            warningDiv.className = 'token-warning-notification';
            warningDiv.innerHTML = `
                <div class="warning-content">
                    <span class="warning-icon">⏰</span>
                    <span class="warning-text">Your session will expire soon. Save your work!</span>
                    <button class="warning-refresh" onclick="refreshToken()">Extend Session</button>
                    <button class="warning-close" onclick="this.parentElement.parentElement.remove()">×</button>
                </div>
            `;

            // Insert at the top of chat container
            const chatContainer = document.querySelector('.chat-container');
            chatContainer.insertBefore(warningDiv, chatContainer.firstChild);

            // Auto-hide after 10 seconds
            setTimeout(() => {
                if (warningDiv.parentNode) {
                    warningDiv.remove();
                }
            }, 10000);
        }

        async function refreshToken() {
            try {
                // Call the login endpoint to get a new token (simulating token refresh)
                const currentToken = localStorage.getItem('token');
                const response = await fetch('/verify-token', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${currentToken}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (response.ok) {
                    const data = await response.json();
                    if (data.valid && data.time_remaining_minutes > 5) {
                        showErrorMessage('Session verified - you have time remaining!', false);
                        setupTokenExpirationWarning(data.time_remaining_seconds);
                    } else {
                        showErrorMessage('Session is about to expire. Please save your work and log in again.');
                    }
                } else {
                    showErrorMessage('Unable to refresh session. Please log in again.');
                    setTimeout(() => {
                        localStorage.removeItem('token');
                        window.location.href = '/login';
                    }, 3000);
                }
            } catch (error) {
                console.error('Token refresh failed:', error);
                showErrorMessage('Network error. Please check your connection.');
            }

            // Remove any warning notifications
            const warnings = document.querySelectorAll('.token-warning-notification');
            warnings.forEach(warning => warning.remove());
        }

        function setupEventListeners() {
            // Send message
            document.getElementById('sendBtn').addEventListener('click', sendMessage);
            document.getElementById('messageInput').addEventListener('keypress', function (e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            });

            // Auto-resize textarea
            document.getElementById('messageInput').addEventListener('input', adjustTextareaHeight);

            // New session
            document.getElementById('newSessionBtn').addEventListener('click', startNewSession);

            // Logout
            document.getElementById('logoutBtn').addEventListener('click', logout);

            // Global ESC key listener for canceling edits
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    // Check if any message is currently being edited
                    const activeEdit = document.querySelector('.cancel-edit-btn[style*="inline-flex"]');
                    if (activeEdit) {
                        e.preventDefault();
                        const messageId = activeEdit.id.replace('cancel-edit-', '');
                        cancelUserMessageEdit(messageId);
                    }
                }
            });

            // Enhanced manual scroll tracking
            const chatMessages = document.getElementById('chatMessages');
            if (chatMessages) {
                chatMessages.addEventListener('scroll', function(e) {
                    // Simple user scroll tracking
                    if (e.isTrusted) {
                        window.lastManualScrollTime = Date.now();
                    }
                }, { passive: true });
            }

            // Pagination (only for authenticated users)
            if (!isGuest) {
                // Add infinite scroll to sessions list
                const sessionsList = document.getElementById('sessionsList');
                sessionsList.addEventListener('scroll', handleSessionsScroll);

                // Mobile menu toggle
                document.getElementById('mobileMenuBtn').addEventListener('click', toggleMobileSidebar);

                // Close mobile sidebar when clicking outside
                document.addEventListener('click', function (e) {
                    if (window.innerWidth <= 768) {
                        const sidebar = document.getElementById('sessionsSidebar');
                        const menuBtn = document.getElementById('mobileMenuBtn');
                        if (!sidebar.contains(e.target) && !menuBtn.contains(e.target)) {
                            sidebar.classList.remove('mobile-open');
                        }
                    }
                });
            }
        }

        async function sendMessage() {
            const messageInput = document.getElementById('messageInput');
            const message = messageInput.value.trim();

            if (!message) return;

            // Check if we're already waiting for a response
            if (isWaitingForResponse()) {
                return;
            }

            // Add user message to chat
            const userMessageDiv = addMessageToChat('user', message);

            messageInput.value = '';
            adjustTextareaHeight();

            // Block input while waiting for response
            setWaitingForResponse(true);

            // Show typing indicator
            showTypingIndicator();

            try {
                const url = currentSessionId ? `/chatbot?session=${currentSessionId}` : '/chatbot';
                let response;
                
                // Prepare request body with message and parent_message_id if needed
                const requestBody = { message };
                
                // If we have a tree path, we need to find the last bot message to use as parent
                if (currentTreePath && currentSessionId) {
                    const lastBotMessage = getLastBotMessageFromCurrentBranch();
                    if (lastBotMessage) {
                        requestBody.parent_message_id = lastBotMessage.id;
                    }
                }
                
                if (isGuest) {
                    // Guest users don't need token refresh
                    response = await fetch(url, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(requestBody)
                    });
                } else {
                    // Authenticated users use the enhanced request wrapper
                    response = await makeAuthenticatedRequest(url, {
                        method: 'POST',
                        body: JSON.stringify(requestBody)
                    });
                }

                const data = await response.json();
                hideTypingIndicator();

                if (response.ok) {
                    if (data.session_id && !currentSessionId) {
                        currentSessionId = data.session_id;
                        updateURL();
                        // Reload sessions to show the new session
                        resetSessionsState();
                        loadSessions(1);
                    }
                    
                    // Check if session title has changed and update sidebar
                    if (data.title && currentSessionId && data.session_id === currentSessionId) {
                        updateSessionTitleInSidebar(currentSessionId, data.title);
                    }
                    
                    // Process branching response
                    let botMessage = '';
                    let botMessageData = null;
                    let userMessageData = null;
                    
                    if (data.messages && data.messages.length > 1) {
                        // Get user and bot message from messages array
                        const userMsg = data.messages.find(msg => msg.sender === 'user');
                        const botMsg = data.messages.find(msg => msg.sender === 'bot');
                        botMessage = botMsg ? botMsg.content : '';
                        botMessageData = botMsg;
                        userMessageData = userMsg;
                        
                        // Update the user message div with proper data for edit controls
                        if (userMessageData && !isGuest) {
                            const lastUserDiv = document.querySelector('.message.user-message:last-of-type');
                            if (lastUserDiv) {
                                // Updating user message with enhanced data
                                // Add message data attributes - convert message_id to id for consistency
                                lastUserDiv.dataset.messageId = userMessageData.message_id || userMessageData.id;
                                lastUserDiv.dataset.connectedFrom = userMessageData.connected_from || '';
                                lastUserDiv.dataset.connectsTo = userMessageData.connects_to || '';
                                lastUserDiv.dataset.connections = userMessageData.connections || 0;
                                
                                // Create a normalized messageData object with 'id' field
                                const normalizedUserData = {
                                    id: userMessageData.message_id || userMessageData.id,
                                    connected_from: userMessageData.connected_from,
                                    connects_to: userMessageData.connects_to,
                                    connections: userMessageData.connections
                                };
                                
                                // Add edit controls if they don't already exist AND it's not the first message
                                if (!lastUserDiv.querySelector('.user-edit-controls')) {
                                    // Adding edit controls to user message
                                    
                                    // Check if this is the first message (connected_from === 'main') or new session
                                    if (normalizedUserData.connected_from !== 'main' && currentSessionId) {
                                        const editControlsDiv = addUserMessageEditControls(lastUserDiv, normalizedUserData, message);
                                        if (editControlsDiv) {
                                            lastUserDiv.appendChild(editControlsDiv);
                                            // Edit controls added successfully
                                        } else {
                                            // Failed to create edit controls - configuration issue
                                        }
                                    } else {
                                        // Edit controls NOT added - first message or new session
                                    }
                                } else {
                                    // Edit controls already exist
                                }
                            } else {
                                // Could not find last user message div
                            }
                        } else {
                            console.log('No user message data or guest mode - userMessageData:', !!userMessageData, 'isGuest:', isGuest);
                        }
                    } else {
                        // Fallback to direct reply field
                        botMessage = data.reply || '';
                    }

                    if (botMessage) {
                        const botDiv = addMessageToChat('bot', botMessage, null, false, botMessageData);
                        
                        // Update stored session messages for branching functionality
                        if (data.messages) {
                            // Add the new messages to our stored session messages
                            data.messages.forEach(newMsg => {
                                // Check if message already exists (avoid duplicates)
                                const existingIndex = currentSessionMessages.findIndex(msg => 
                                    (msg.id || msg.message_id) === (newMsg.id || newMsg.message_id)
                                );
                                if (existingIndex === -1) {
                                    currentSessionMessages.push(newMsg);
                                } else {
                                    // Update existing message with new data
                                    currentSessionMessages[existingIndex] = newMsg;
                                }
                            });
                            
                            updateBranchStructure(data.messages);
                        }
                        
                        // Update tree path display if needed
                        updateTreePathDisplay();
                        
                        // Otomatik tree path güncellemesi - bot response aldıktan sonra
                        if (currentSessionId && !isGuest && currentTreePath) {
                            console.log('🔄 Auto-extending tree path after bot response...');
                            saveLastTreePath(currentSessionId, currentTreePath);
                        }
                        
                        // Refresh sessions list to reflect potential title changes and reorder by lastChangeMade
                        if (currentSessionId && !isGuest) {
                            console.log('Refreshing sessions list after message exchange...');
                            resetSessionsState();
                            loadSessions(1);
                        }
                    } else {
                        showErrorMessage('Received empty response from the chatbot. Please try again.');
                    }
                } else {
                    // Check for authentication/authorization errors (403/404)
                    if (response.status === 403 || response.status === 404) {
                        const errorMessage = data.message || 'Access denied';
                        if (shouldRedirectToLogin(errorMessage)) {
                            localStorage.removeItem('token');
                            window.location.href = '/login';
                            return;
                        }
                    }
                    
                    // Check for 500 errors - add action buttons to user message
                    if (response.status === 500) {
                        addActionButtonsToMessage(userMessageDiv, message);
                        showErrorMessage(data.message || 'Server error occurred. You can try again, edit, or delete this message.', true);
                    } else {
                        showErrorMessage(data.message || 'An error occurred');
                    }
                }
            } catch (error) {
                hideTypingIndicator();
                // Network or other errors - add action buttons
                addActionButtonsToMessage(userMessageDiv, message);
                showErrorMessage('Failed to send message. Please try again.', true);
                console.error('Send message error:', error);
            } finally {
                // Unblock input after response (success or error)
                setWaitingForResponse(false);
            }
        }

        function addMessageToChat(sender, message, timestamp = null, showActions = false, messageData = null, shouldScroll = true) {
            const chatMessages = document.getElementById('chatMessages');

            // Remove welcome message if it exists
            const welcomeMessage = chatMessages.querySelector('.welcome-message');
            if (welcomeMessage) {
                welcomeMessage.remove();
            }

            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${sender}-message`;
            
            // Add message data attributes for branching
            if (messageData) {
                messageDiv.dataset.messageId = messageData.id;
                messageDiv.dataset.connectedFrom = messageData.connected_from || '';
                messageDiv.dataset.connectsTo = messageData.connects_to || '';
                messageDiv.dataset.connections = messageData.connections || 0;
            }

            const messageContent = document.createElement('div');
            messageContent.className = 'message-content';

            // Process message for code blocks
            const processedMessage = processCodeBlocks(message);
            messageContent.innerHTML = processedMessage;

            const timestampDiv = document.createElement('div');
            timestampDiv.className = 'message-timestamp';

            // Use provided timestamp or current time for new messages
            if (timestamp) {
                const messageTime = new Date(timestamp);
                timestampDiv.textContent = messageTime.toLocaleString();
            } else {
                timestampDiv.textContent = new Date().toLocaleTimeString();
            }

            messageDiv.appendChild(messageContent);
            messageDiv.appendChild(timestampDiv);

            // Add copy button for bot messages (hover to show, mobile friendly)
            if (sender === 'bot' && messageData && messageData.id) {
                const copyButtonDiv = document.createElement('div');
                copyButtonDiv.className = 'message-copy-container';
                
                copyButtonDiv.innerHTML = `
                    <button class="message-copy-btn" onclick="copyMessage('${messageData.id}')" title="Copy message">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                        </svg>
                    </button>
                `;
                
                messageDiv.appendChild(copyButtonDiv);
            }

            // Add branch navigation for user messages that connect FROM bot messages with multiple branches (ChatGPT style)
            if (sender === 'user' && messageData && messageData.connected_from) {
                // Find the bot message this user message connects from
                const allMessages = getCurrentSessionMessages();
                const parentBotMessage = allMessages.find(msg => 
                    msg.id.toString() === messageData.connected_from.toString() && msg.sender === 'bot'
                );
                
                if (parentBotMessage && parentBotMessage.connections > 1) {
                    // Adding branch navigation for user message
                    const navigationDiv = addBranchNavigationControls(messageDiv, {
                        id: messageData.id,
                        connects_to: parentBotMessage.connects_to,
                        connections: parentBotMessage.connections,
                        parent_bot_id: parentBotMessage.id
                    });
                    if (navigationDiv) {
                        messageDiv.appendChild(navigationDiv);
                        // Branch navigation added successfully
                    } else {
                        // addBranchNavigationControls returned null
                    }
                } else {
                    console.log('No branch navigation needed - parent bot has', parentBotMessage?.connections || 0, 'connections');
                }
            } else {
                console.log('Branch navigation NOT checked - sender:', sender, 'messageData:', !!messageData, 'connected_from:', messageData?.connected_from);
            }

            // Add ChatGPT-style edit button for user messages (not guest mode, not first message, and not new session)
            if (sender === 'user' && !isGuest && messageData && messageData.connected_from !== 'main' && currentSessionId) {
                // Adding edit controls for user message
                const editControlsDiv = addUserMessageEditControls(messageDiv, messageData, message);
                if (editControlsDiv) {
                    messageDiv.appendChild(editControlsDiv);
                    // Edit controls added successfully
                } else {
                    // addUserMessageEditControls returned null
                }
            } else {
                console.log('Edit controls NOT added - sender:', sender, 'isGuest:', isGuest, 'messageData:', !!messageData, 'connected_from:', messageData?.connected_from, 'currentSessionId:', currentSessionId);
            }

            // Add action buttons for user messages that failed to send
            if (showActions && sender === 'user') {
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'message-actions';
                actionsDiv.innerHTML = `
                    <button class="action-btn delete-btn" onclick="deleteMessage(this)" title="Delete message">🗑️</button>
                    <button class="action-btn retry-btn" onclick="retryMessage(this, '${message.replace(/'/g, "\\'")}', '${messageDiv.dataset.originalMessage || message}')" title="Try again">🔄</button>
                    <button class="action-btn edit-btn" onclick="editMessage(this, '${message.replace(/'/g, "\\'")}', '${messageDiv.dataset.originalMessage || message}')" title="Edit message">✏️</button>
                `;
                messageDiv.appendChild(actionsDiv);
                messageDiv.dataset.originalMessage = message;
            }

            chatMessages.appendChild(messageDiv);
            
            // Only auto-scroll if requested (for new messages, not branch navigation)
            if (shouldScroll) {
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }
            
            const newBlocks = messageDiv.querySelectorAll("pre code");
            newBlocks.forEach(block => hljs.highlightElement(block));

            return messageDiv;
        }

        function showErrorMessage(message, hasActionButtons = false) {
            // Check if this is an authentication/authorization error that should redirect to login
            if (shouldRedirectToLogin(message)) {
                localStorage.removeItem('token'); // Clear any invalid token
                window.location.href = '/login';
                return;
            }

            // Check if this is an API failure that should refresh the page
            // BUT only if we don't have action buttons available for the user
            if (!hasActionButtons && shouldRefreshPage(message)) {
                setTimeout(() => {
                    window.location.reload();
                }, 2000); // Give user 2 seconds to see the error message
            }

            // Remove any existing error messages
            const existingError = document.querySelector('.error-notification');
            if (existingError) {
                existingError.remove();
            }

            // Create error notification
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-notification';
            errorDiv.innerHTML = `
                <div class="error-content">
                    <span class="error-icon">⚠️</span>
                    <span class="error-text">${message}</span>
                    <button class="error-close" onclick="this.parentElement.parentElement.remove()">×</button>
                </div>
            `;

            // Insert at the top of chat container
            const chatContainer = document.querySelector('.chat-container');
            chatContainer.insertBefore(errorDiv, chatContainer.firstChild);

            // Auto-hide after 5 seconds (unless page is refreshing)
            if (!(!hasActionButtons && shouldRefreshPage(message))) {
                setTimeout(() => {
                    if (errorDiv.parentNode) {
                        errorDiv.remove();
                    }
                }, 5000);
            }
        }

        function shouldRedirectToLogin(message) {
            // List of error messages that indicate authentication/authorization issues
            const authErrorMessages = [
                "Forbidden: Guest users cannot access session messages.",
                "Forbidden: You do not have access to this session.",
                "Guest users cannot create or access sessions.",
                "No active session available for guest users."
            ];
            
            return authErrorMessages.some(authMsg => message.includes(authMsg));
        }

        function shouldRefreshPage(message) {
            // List of error messages that indicate API failures requiring page refresh
            const apiFailureMessages = [
                "Failed to get a reply from the API."
            ];
            
            return apiFailureMessages.some(apiMsg => message.includes(apiMsg));
        }

        function hideTypingIndicator() {
            const typingIndicator = document.getElementById('typingIndicator');
            if (typingIndicator) {
                typingIndicator.remove();
            }
            isTypingIndicatorActive = false;
        }

        function removeTypingIndicator() {
            hideTypingIndicator();
        }

        function showTypingIndicator() {
            // First, ensure any existing typing indicator is removed
            hideTypingIndicator();
            
            const chatMessages = document.getElementById('chatMessages');
            if (!chatMessages) return;
            
            // Set global state
            isTypingIndicatorActive = true;
            
            const typingDiv = document.createElement('div');
            typingDiv.className = 'message bot-message typing-indicator';
            typingDiv.id = 'typingIndicator';
            typingDiv.innerHTML = '<div class="message-content">Typing<span class="dots">...</span></div>';
            
            // Add multiple attributes to make it more identifiable
            typingDiv.setAttribute('data-typing', 'true');
            typingDiv.setAttribute('data-persistent', 'true');
            typingDiv.style.display = 'flex';
            typingDiv.style.flexDirection = 'column';
            
            chatMessages.appendChild(typingDiv);
            
            // Smooth scroll to typing indicator with buffer
            const scrollToTyping = () => {
                const typingElement = document.getElementById('typingIndicator');
                if (typingElement) {
                    // Use smooth scrolling to center the typing indicator
                    typingElement.scrollIntoView({ 
                        behavior: 'smooth', 
                        block: 'end',
                        inline: 'nearest'
                    });
                    
                    // Add buffer after smooth scroll completes
                    setTimeout(() => {
                        const currentScroll = chatMessages.scrollTop;
                        const maxScroll = chatMessages.scrollHeight - chatMessages.clientHeight;
                        const bufferAmount = Math.min(300, maxScroll - currentScroll);
                        if (bufferAmount > 0) {
                            // Smooth scroll to add buffer
                            chatMessages.scrollTo({
                                top: currentScroll + bufferAmount,
                                behavior: 'smooth'
                            });
                        }
                    }, 400); // Wait for smooth scroll to complete
                } else {
                    // Fallback: smooth scroll to bottom if typing element not found
                    chatMessages.scrollTo({
                        top: chatMessages.scrollHeight,
                        behavior: 'smooth'
                    });
                }
            };
            
            // Single smooth scroll with delay for DOM updates
            setTimeout(() => {
                scrollToTyping();
            }, 50); // Small delay to let DOM update
            
            // Enhanced backup restoration with multiple attempts
            const restoreTypingIndicator = () => {
                if (isTypingIndicatorActive && !document.getElementById('typingIndicator')) {
                    console.log('Typing indicator lost, restoring...');
                    const backupDiv = document.createElement('div');
                    backupDiv.className = 'message bot-message typing-indicator';
                    backupDiv.id = 'typingIndicator';
                    backupDiv.innerHTML = '<div class="message-content">Typing<span class="dots">...</span></div>';
                    backupDiv.setAttribute('data-typing', 'true');
                    backupDiv.setAttribute('data-persistent', 'true');
                    backupDiv.style.display = 'flex';
                    backupDiv.style.flexDirection = 'column';
                    
                    const messages = document.getElementById('chatMessages');
                    if (messages) {
                        messages.appendChild(backupDiv);
                        // Force scroll to ensure visibility
                        messages.scrollTop = messages.scrollHeight;
                        
                        // Ensure it's really visible
                        setTimeout(() => {
                            const restored = document.getElementById('typingIndicator');
                            if (restored) {
                                restored.scrollIntoView({ behavior: 'smooth', block: 'end' });
                            }
                        }, 10);
                    }
                }
            };
            
            // Multiple restoration attempts
            setTimeout(restoreTypingIndicator, 100);
            setTimeout(restoreTypingIndicator, 200);
            setTimeout(restoreTypingIndicator, 500);
        }

        function adjustTextareaHeight() {
            const textarea = document.getElementById('messageInput');
            
            // Reset height to auto to get accurate scrollHeight
            textarea.style.height = 'auto';
            
            // Calculate new height
            const newHeight = Math.min(textarea.scrollHeight, 120);
            textarea.style.height = newHeight + 'px';
            
            // Show scrollbar only if content exceeds max height
            if (textarea.scrollHeight > 120) {
                textarea.style.overflowY = 'auto';
            } else {
                textarea.style.overflowY = 'hidden';
            }
        }

        async function loadSessions(page = 1, append = false) {
            if (isGuest || isLoadingSessions) return;
            
            // If we're appending and there are no more sessions, don't load
            if (append && !hasMoreSessions) return;

            isLoadingSessions = true;
            console.log(`Loading sessions for page: ${page}, append: ${append}`);

            try {
                const response = await makeAuthenticatedRequest(`/chatbot/session?page=${page}`, {
                    method: 'GET'
                });

                const data = await response.json();
                console.log('Sessions response:', data);

                if (response.ok) {
                    displaySessions(data.sessions || [], append);
                    currentPage = page;
                    hasMoreSessions = data.has_next;
                    console.log(`Updated currentPage to: ${currentPage}, has_next: ${data.has_next}`);
                    
                    // If we have a session ID from URL and this is the first load, automatically load that session
                    if (!append && currentSessionId && currentSessionId !== 'guest') {
                        const sessionFromUrl = currentSessionId;
                        currentSessionId = null; // Reset to prevent infinite loops
                        setTimeout(() => {
                            loadSessionById(sessionFromUrl);
                        }, 100);
                    }
                } else {
                    // Check for authentication/authorization errors
                    if (response.status === 403 || response.status === 404) {
                        const errorMessage = data.message || 'Access denied';
                        if (shouldRedirectToLogin(errorMessage)) {
                            localStorage.removeItem('token');
                            window.location.href = '/login';
                            return;
                        }
                    }
                    if (!append) {
                        document.getElementById('sessionsList').innerHTML =
                            '<div class="no-sessions">No sessions found</div>';
                    }
                }
            } catch (error) {
                console.error('Load sessions error:', error);
                showErrorMessage('Failed to load sessions. Please try again.');
                if (!append) {
                    document.getElementById('sessionsList').innerHTML =
                        '<div class="error-sessions">Failed to load sessions</div>';
                }
            } finally {
                isLoadingSessions = false;
            }
        }

        async function loadSessionById(sessionId) {
            console.log(`Loading session by ID: ${sessionId}`);
            try {
                // First, try to find the session in the current list
                const sessionDiv = document.querySelector(`[data-session-id="${sessionId}"]`);
                if (sessionDiv) {
                    console.log('Found session in current list, loading...');
                    await loadSession(sessionId);
                    return;
                }
                
                // If not found in current list, try to load more sessions
                let page = 2;
                while (hasMoreSessions) {
                    await loadSessions(page, true);
                    const sessionDiv = document.querySelector(`[data-session-id="${sessionId}"]`);
                    if (sessionDiv) {
                        console.log(`Found session on page ${page}, loading...`);
                        await loadSession(sessionId);
                        return;
                    }
                    page++;
                }
                
                // If session still not found, try to load it directly
                console.log('Session not found in list, attempting direct load...');
                await loadSession(sessionId);
            } catch (error) {
                console.error('Error loading session by ID:', error);
                showErrorMessage(`Failed to load session ${sessionId}`);
            }
        }

        function displaySessions(sessions, append = false) {
            const sessionsList = document.getElementById('sessionsList');
            
            // Only clear the list if we're not appending
            if (!append) {
                sessionsList.innerHTML = '';
            }

            // Sessions are already sorted by lastChangeMade DESC from backend
            // No need to re-sort in frontend
            sessions.forEach(session => {
                const sessionDiv = document.createElement('div');
                sessionDiv.className = 'session-item';
                sessionDiv.setAttribute('data-session-id', session.id);
                if (session.id === currentSessionId) {
                    sessionDiv.classList.add('active');
                }

                // Handle created_at properly
                const createdAt = session.created_at ? new Date(session.created_at).toLocaleDateString() : 'Unknown date';

                sessionDiv.innerHTML = `
                    <div class="session-content">
                        <div class="session-title">${session.title || 'Session ' + session.id}</div>
                        <div class="session-date">${createdAt}</div>
                    </div>
                    <div class="session-actions">
                        <button class="session-edit-btn" title="Edit session title" onclick="editSessionTitle(event, '${session.id}', '${(session.title || 'Session ' + session.id).replace(/'/g, '\\\'')}')" style="display: none;">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M12 20h9"></path>
                                <path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>
                            </svg>
                        </button>
                        <button class="session-delete-btn" title="Delete session" onclick="deleteSession(event, '${session.id}')">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="3,6 5,6 21,6"></polyline>
                                <path d="m19,6v14a2,2 0 0,1-2,2H7a2,2 0 0,1-2-2V6m3,0V4a2,2 0 0,1,2-2h4a2,2 0 0,1,2,2v2"></path>
                                <line x1="10" y1="11" x2="10" y2="17"></line>
                                <line x1="14" y1="11" x2="14" y2="17"></line>
                            </svg>
                        </button>
                    </div>
                `;

                sessionDiv.addEventListener('click', (e) => {
                    // Don't load session if edit or delete button was clicked
                    if (!e.target.closest('.session-edit-btn') && !e.target.closest('.session-delete-btn')) {
                        // Close mobile sidebar when session is selected
                        const sidebar = document.getElementById('sessionsSidebar');
                        if (sidebar && sidebar.classList.contains('mobile-open')) {
                            sidebar.classList.remove('mobile-open');
                        }
                        loadSession(session.id);
                    }
                });
                sessionsList.appendChild(sessionDiv);
            });
        }

        async function editSessionTitle(event, sessionId, currentTitle) {
            event.preventDefault();
            event.stopPropagation();
            
            if (isGuest) {
                showErrorMessage('Session editing is only available for authenticated users.');
                return;
            }
            
            // Create a temporary input field
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentTitle;
            input.className = 'session-title-edit-input';
            input.maxLength = 100;
            
            // Find the session div and title element
            const sessionDiv = document.querySelector(`[data-session-id="${sessionId}"]`);
            const titleElement = sessionDiv.querySelector('.session-title');
            const originalText = titleElement.textContent;
            
            // Replace title with input
            titleElement.style.display = 'none';
            titleElement.parentNode.insertBefore(input, titleElement.nextSibling);
            
            // Focus and select all text
            input.focus();
            input.select();
            
            let isEditing = true;
            
            const saveEdit = async () => {
                if (!isEditing) return;
                isEditing = false;
                
                const newTitle = input.value.trim();
                
                if (!newTitle) {
                    showErrorMessage('Session title cannot be empty.');
                    cancelEdit();
                    return;
                }
                
                if (newTitle === currentTitle) {
                    cancelEdit();
                    return;
                }
                
                try {
                    const currentToken = localStorage.getItem('token');
                    if (!currentToken) {
                        showErrorMessage('Authentication required. Please log in again.');
                        cancelEdit();
                        return;
                    }
                    
                    const response = await fetch('/chatbot/session/update', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${currentToken}`,
                        },
                        body: JSON.stringify({
                            session_id: sessionId,
                            title: newTitle
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (response.ok) {
                        // Update the title in the UI
                        titleElement.textContent = newTitle;
                        titleElement.style.display = '';
                        input.remove();
                        showSuccessMessage('Session title updated successfully.');
                        
                        // Update browser title if this is the current session
                        if (currentSessionId === sessionId) {
                            document.title = `${newTitle} - Flask Chatbot`;
                        }
                    } else {
                        showErrorMessage(data.message || 'Failed to update session title.');
                        cancelEdit();
                    }
                } catch (error) {
                    console.error('Error updating session title:', error);
                    showErrorMessage('Network error occurred while updating session title.');
                    cancelEdit();
                }
            };
            
            const cancelEdit = () => {
                if (input && input.parentNode) {
                    titleElement.style.display = '';
                    input.remove();
                }
                isEditing = false;
            };
            
            // Handle Enter key
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    saveEdit();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    cancelEdit();
                }
            });
            
            // Handle clicking outside
            input.addEventListener('blur', () => {
                if (isEditing) {
                    saveEdit();
                }
            });
        }

        function handleSessionsScroll() {
            const sessionsList = document.getElementById('sessionsList');
            const scrollTop = sessionsList.scrollTop;
            const scrollHeight = sessionsList.scrollHeight;
            const clientHeight = sessionsList.clientHeight;
            
            // If we're within 50px of the bottom and not already loading
            if (scrollTop + clientHeight >= scrollHeight - 50 && !isLoadingSessions && hasMoreSessions) {
                console.log('Loading more sessions...');
                loadSessions(currentPage + 1, true);
            }
        }

        function resetSessionsState() {
            currentPage = 1;
            hasMoreSessions = true;
            isLoadingSessions = false;
        }

        function updateSessionTitleInSidebar(sessionId, newTitle) {
            // Find the session div with the matching data-session-id attribute
            const sessionDiv = document.querySelector(`[data-session-id="${sessionId}"]`);
            if (sessionDiv) {
                // Update the session title in the sidebar
                const titleElement = sessionDiv.querySelector('.session-title');
                if (titleElement) {
                    titleElement.textContent = newTitle || `Session ${sessionId}`;
                }
            }
        }

        async function deleteSession(event, sessionId) {
            event.stopPropagation(); // Prevent triggering the session click event
            
            // Show confirmation dialog
            if (!confirm('Are you sure you want to delete this session? This action cannot be undone.')) {
                return;
            }
            
            try {
                const response = await makeAuthenticatedRequest(`/chatbot/delete?session=${sessionId}`, {
                    method: 'GET'
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    // Show success message
                    showSuccessMessage(data.message || 'Session deleted successfully');
                    
                    // If this was the current session, clear the chat and redirect to new session
                    if (currentSessionId === sessionId) {
                        currentSessionId = null;
                        updateURL();
                        // Clear chat messages
                        const chatMessages = document.getElementById('chatMessages');
                        chatMessages.innerHTML = `
                            <div class="welcome-message">
                                <h3>Welcome to HSS GPT! 👋</h3>
                                <p>How can I help you today?</p>
                            </div>
                        `;
                    }
                    
                    // Reload sessions to update the sidebar
                    resetSessionsState();
                    loadSessions(1);
                } else {
                    // Handle specific error cases
                    if (response.status === 403) {
                        showErrorMessage('You do not have permission to delete this session.');
                    } else if (response.status === 404) {
                        showErrorMessage('Session not found.');
                    } else {
                        showErrorMessage(data.message || 'Failed to delete session. Please try again.');
                    }
                }
            } catch (error) {
                console.error('Delete session error:', error);
                showErrorMessage('Failed to delete session. Please check your connection and try again.');
            }
        }

        function showSuccessMessage(message) {
            const errorDiv = document.getElementById('errorMessage');
            if (errorDiv) {
                errorDiv.textContent = message;
                errorDiv.style.backgroundColor = '#22c55e';
                errorDiv.style.borderColor = '#16a34a';
                errorDiv.style.color = 'white';
                errorDiv.style.display = 'block';
                
                setTimeout(() => {
                    errorDiv.style.display = 'none';
                }, 3000);
            }
        }

        async function loadSession(sessionId) {
            try {
                // Close mobile sidebar when session is selected
                const sidebar = document.getElementById('sessionsSidebar');
                if (sidebar && sidebar.classList.contains('mobile-open')) {
                    sidebar.classList.remove('mobile-open');
                }
                
                // Reset tree path when loading a new session
                currentTreePath = null;
                
                const response = await makeAuthenticatedRequest(`/chatbot/message?session=${sessionId}`, {
                    method: 'GET'
                });

                const data = await response.json();

                if (response.ok) {
                    currentSessionId = sessionId;
                    updateURL();
                    
                    // Store complete session messages for branch navigation
                    const messages = data.data || [];
                    currentSessionMessages = messages;
                    
                    // Try to retrieve the last tree path user viewed for this session
                    const savedTreePath = await getLastTreePath(sessionId);
                    
                    if (savedTreePath && messages.length > 0) {
                        // Validate that the saved tree path is still valid with current messages
                        const pathIds = savedTreePath.split(',').filter(id => id !== '');
                        const validPath = pathIds.every(id => {
                            if (id === '') return true; // Root is always valid
                            return messages.some(msg => msg.id.toString() === id);
                        });
                        
                        if (validPath) {
                            // Kaydedilmiş path'i genişletmeye çalış
                            console.log('📋 Extending saved tree path with new messages...');
                            const extendedPath = calculateLatestBranchPath(messages, savedTreePath);
                            
                            // Eğer path uzadıysa, yeni path'i kaydet
                            if (extendedPath !== savedTreePath) {
                                console.log('🔄 Extended saved path with new messages');
                                console.log('Old path:', savedTreePath);
                                console.log('New path:', extendedPath);
                                currentTreePath = extendedPath;
                                saveLastTreePath(sessionId, currentTreePath);
                            } else {
                                currentTreePath = savedTreePath;
                                console.log('Restored saved tree path (no new messages):', savedTreePath);
                            }
                        } else {
                            // Kaydedilmiş path geçersizse, ana daldan başlayıp genişlet
                            console.log('Saved tree path invalid, calculating from main tree...');
                            currentTreePath = calculateMainTreePathWithFailsafe(messages, '');
                            console.log('New calculated path:', currentTreePath);
                            saveLastTreePath(sessionId, currentTreePath);
                        }
                    } else {
                        // Hiç kaydedilmiş path yok, ana daldan başlayıp genişlet
                        if (messages.length > 0) {
                            console.log('🆕 No saved path, calculating from main tree...');
                            currentTreePath = calculateMainTreePathWithFailsafe(messages, '');
                            // İlk path'i veritabanına kaydet
                            saveLastTreePath(sessionId, currentTreePath);
                            console.log('💾 Saved initial tree path:', currentTreePath);
                        }
                    }
                    
                    displayMessages(messages); // Use filtering to show only main branch
                    // Update active session in sidebar
                    updateActiveSession(sessionId);
                    // Check if we should block input after loading messages
                    checkIfWaitingForResponse();
                } else {
                    // Check for authentication/authorization errors
                    if (response.status === 403 || response.status === 404) {
                        const errorMessage = data.message || 'Access denied';
                        if (shouldRedirectToLogin(errorMessage)) {
                            localStorage.removeItem('token');
                            window.location.href = '/login';
                            return;
                        }
                    }
                    showErrorMessage(data.message || 'Failed to load session');
                }
            } catch (error) {
                console.error('Load session error:', error);
                showErrorMessage('Failed to load session. Please try again.');
            }
        }

        function displayMessages(messages) {
            const chatMessages = document.getElementById('chatMessages');
            
            // Store typing indicator state before clearing
            const wasTypingActive = isTypingIndicatorActive;
            const typingIndicator = document.getElementById('typingIndicator');
            let typingHTML = '';
            if (typingIndicator && wasTypingActive) {
                typingHTML = typingIndicator.outerHTML;
            }
            
            chatMessages.innerHTML = '';

            if (messages.length === 0) {
                chatMessages.innerHTML = `
                    <div class="welcome-message">
                        <h3>Session Loaded!</h3>
                        <p>Continue your conversation or start a new topic.</p>
                    </div>
                `;
                return;
            }

            // Clear conversation branches
            currentConversationBranches = {};

            // Filter messages based on current tree path
            let messagesToDisplay = messages;
            
            if (currentTreePath) {
                const pathIds = currentTreePath.split(',').filter(id => id !== '');
                
                // Only show messages that are in the current tree path
                messagesToDisplay = messages.filter(msg => {
                    const isInPath = pathIds.includes(msg.id.toString());
                    return isInPath;
                });
            }

            messagesToDisplay.forEach((msg, index) => {
                const messageDiv = addMessageToChat(msg.sender, msg.content, msg.created_at, false, msg, false); // Don't auto-scroll for branch navigation
                
                // Store branch information
                if (msg.connects_to && msg.connections > 0) {
                    currentConversationBranches[msg.id] = {
                        connects_to: msg.connects_to,
                        connections: msg.connections
                    };
                    
                    // Add visual indicator for messages with branches
                    messageDiv.classList.add('has-branches');
                }
            });
            
            // Restore typing indicator if it was active
            if (typingHTML && wasTypingActive) {
                chatMessages.insertAdjacentHTML('beforeend', typingHTML);
                // Restore global state
                isTypingIndicatorActive = true;
            }
            
            // Ensure all bot messages have copy buttons (for loaded sessions)
            setTimeout(() => {
                const botMessages = chatMessages.querySelectorAll('.bot-message');
                botMessages.forEach(messageDiv => {
                    // Check if copy button already exists
                    if (!messageDiv.querySelector('.message-copy-container')) {
                        const messageId = messageDiv.dataset.messageId;
                        if (messageId) {
                            const copyButtonDiv = document.createElement('div');
                            copyButtonDiv.className = 'message-copy-container';
                            
                            copyButtonDiv.innerHTML = `
                                <button class="message-copy-btn" onclick="copyMessage('${messageId}')" title="Copy message">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                                    </svg>
                                </button>
                            `;
                            
                            messageDiv.appendChild(copyButtonDiv);
                        }
                    }
                });
            }, 100);
            
            // Scroll to bottom after loading all messages (initial session load)
            chatMessages.scrollTop = chatMessages.scrollHeight;
            
            // Update tree path display
            updateTreePathDisplay();
        }

        function startNewSession() {
            currentSessionId = null;
            currentTreePath = null;
            currentConversationBranches = {};
            currentSessionMessages = []; // Clear session messages for new session
            
            // Clear any existing typing indicator since this is a fresh start
            hideTypingIndicator();
            
            document.getElementById('chatMessages').innerHTML = `
                <div class="welcome-message">
                    <h3>New Conversation Started!</h3>
                    <p>What would you like to talk about?</p>
                </div>
            `;
            updateURL();
            updateTreePathDisplay();
            // Clear active session highlighting
            updateActiveSession(null);
        }

        function updateActiveSession(sessionId) {
            // Remove active class from all sessions
            document.querySelectorAll('.session-item').forEach(item => {
                item.classList.remove('active');
            });

            // Add active class to current session
            if (sessionId) {
                const activeSession = document.querySelector(`[data-session-id="${sessionId}"]`);
                if (activeSession) {
                    activeSession.classList.add('active');
                }
            }
        }

        function updateURL() {
            const url = new URL(window.location);
            if (currentSessionId && currentSessionId !== 'guest') {
                url.searchParams.set('session', currentSessionId);
            } else {
                url.searchParams.delete('session');
            }
            window.history.pushState({}, '', url);
        }

        function toggleMobileSidebar() {
            const sidebar = document.getElementById('sessionsSidebar');
            sidebar.classList.toggle('mobile-open');
        }

        function logout() {
            localStorage.removeItem('token');
            window.location.href = '/';
        }

        function processCodeBlocks(text) {
            // helper to escape <, > and &
            const escapeHtml = str =>
                str.replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;");

            // 1) Pull out fenced-code blocks into placeholders
            const codeBlocks = [];
            text = text.replace(
                /```(\w+)?\r?\n([\s\S]*?)```/g,
                (_, lang = "text", code) => {
                    const id = codeBlocks.length;
                    codeBlocks.push({ lang, code });
                    return `@@CODE${id}@@`;
                }
            );

            // 2) Escape the rest of the text
            text = escapeHtml(text);

            // 3) Markdown → HTML on non-code text
            text = text
                // First handle list items (before italic processing to avoid conflicts)
                .replace(/^\s*[-*•]\s+(.+)$/gm, "<li>$1</li>")
                // Wrap consecutive list items in <ul> tags
                .replace(/(<li>.*?<\/li>)(\s*<li>.*?<\/li>)*/gs, m => {
                    // Remove any existing <ul> wrapping first
                    const cleanedList = m.replace(/<\/?ul>/g, '');
                    return `<ul>${cleanedList}</ul>`;
                })
                // Bold (do this before italics to avoid conflicts)
                .replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>")
                .replace(/__(.*?)__/g, "<strong>$1</strong>")
                // Italics (more careful pattern to avoid conflicts with bullets)
                .replace(/(^|[^*])\*([^*\n][^*]*?[^*])\*(?!\*)/g, "$1<em>$2</em>")
                .replace(/(^|[^_])_([^_\n][^_]*?[^_])_(?!_)/g, "$1<em>$2</em>")
                // Convert newlines to <br> (but not inside lists)
                .replace(/\n(?!<\/?(ul|li))/g, "<br>");

            // 4) Restore each code block, escaping its interior but leaving its newlines
            codeBlocks.forEach(({ lang, code }, i) => {
                const blockId = `code-block-${Date.now()}-${i}`;
                const blockHtml =
                    `<div class="code-block" data-block-id="${blockId}">` +
                    `<div class="code-header">` +
                    `<span class="code-language">${lang}</span>` +
                    `<button class="code-copy-btn" onclick="copyCodeBlock('${blockId}')" title="Copy code">` +
                    `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">` +
                    `<rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>` +
                    `<path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>` +
                    `</svg>` +
                    `</button>` +
                    `</div>` +
                    `<pre><code class="language-${lang}" data-code="${escapeHtml(code).replace(/"/g, '&quot;')}">` +
                    escapeHtml(code) +
                    `</code></pre>` +
                    `</div>`;
                text = text.replace(new RegExp(`@@CODE${i}@@`, "g"), blockHtml);
            });

            return text;
        }

        // Copy code block functionality
        function copyCodeBlock(blockId) {
            try {
                const codeBlock = document.querySelector(`[data-block-id="${blockId}"]`);
                if (!codeBlock) {
                    console.error('Code block not found:', blockId);
                    return;
                }
                
                const codeElement = codeBlock.querySelector('code');
                if (!codeElement) {
                    console.error('Code element not found in block:', blockId);
                    return;
                }
                
                // Get the raw code from data attribute or text content
                const codeText = codeElement.dataset.code || codeElement.textContent;
                
                // Use async clipboard API with fallback
                if (navigator.clipboard && window.isSecureContext) {
                    navigator.clipboard.writeText(codeText).then(() => {
                        showCopySuccess(codeBlock.querySelector('.code-copy-btn'));
                    }).catch((err) => {
                        console.error('Clipboard API failed:', err);
                        fallbackCopyToClipboard(codeText, codeBlock.querySelector('.code-copy-btn'));
                    });
                } else {
                    fallbackCopyToClipboard(codeText, codeBlock.querySelector('.code-copy-btn'));
                }
            } catch (error) {
                console.error('Error copying code block:', error);
            }
        }

        // Copy entire message functionality
        function copyMessage(messageId) {
            try {
                const messageDiv = document.querySelector(`[data-message-id="${messageId}"]`);
                if (!messageDiv) {
                    console.error('Message not found:', messageId);
                    return;
                }
                
                const messageContent = messageDiv.querySelector('.message-content');
                if (!messageContent) {
                    console.error('Message content not found for:', messageId);
                    return;
                }
                
                // Get the plain text content, preserving line breaks
                const textContent = getMessagePlainText(messageContent);
                
                // Use async clipboard API with fallback
                if (navigator.clipboard && window.isSecureContext) {
                    navigator.clipboard.writeText(textContent).then(() => {
                        const copyBtn = messageDiv.querySelector('.message-copy-btn');
                        showCopySuccess(copyBtn);
                    }).catch((err) => {
                        console.error('Clipboard API failed:', err);
                        const copyBtn = messageDiv.querySelector('.message-copy-btn');
                        fallbackCopyToClipboard(textContent, copyBtn);
                    });
                } else {
                    const copyBtn = messageDiv.querySelector('.message-copy-btn');
                    fallbackCopyToClipboard(textContent, copyBtn);
                }
            } catch (error) {
                console.error('Error copying message:', error);
            }
        }

        // Fallback copy function for older browsers or non-secure contexts
        function fallbackCopyToClipboard(text, button) {
            try {
                const textArea = document.createElement('textarea');
                textArea.value = text;
                textArea.style.position = 'fixed';
                textArea.style.left = '-999999px';
                textArea.style.top = '-999999px';
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                
                const successful = document.execCommand('copy');
                document.body.removeChild(textArea);
                
                if (successful) {
                    showCopySuccess(button);
                } else {
                    console.error('Fallback copy failed');
                    showCopyError(button);
                }
            } catch (err) {
                console.error('Fallback copy error:', err);
                showCopyError(button);
            }
        }

        function getMessagePlainText(messageContent) {
            // Clone the content to avoid modifying the original
            const clone = messageContent.cloneNode(true);
            
            // Replace code blocks with their plain text
            const codeBlocks = clone.querySelectorAll('.code-block');
            codeBlocks.forEach(block => {
                const langElement = block.querySelector('.code-language');
                const codeElement = block.querySelector('code');
                if (codeElement) {
                    const lang = langElement ? langElement.textContent.trim() : '';
                    const code = codeElement.dataset.code || codeElement.textContent;
                    const replacement = document.createTextNode(`\`\`\`${lang}\n${code}\n\`\`\``);
                    block.replaceWith(replacement);
                }
            });
            
            // Handle other elements before getting text content
            const strongElements = clone.querySelectorAll('strong');
            strongElements.forEach(el => {
                el.replaceWith(document.createTextNode(`**${el.textContent}**`));
            });
            
            const emElements = clone.querySelectorAll('em');
            emElements.forEach(el => {
                el.replaceWith(document.createTextNode(`*${el.textContent}*`));
            });
            
            // Replace <br> tags with newlines
            clone.innerHTML = clone.innerHTML.replace(/<br\s*\/?>/gi, '\n');
            
            // Replace list items with markdown format
            const listItems = clone.querySelectorAll('li');
            listItems.forEach(li => {
                li.textContent = `• ${li.textContent}`;
            });
            
            // Handle nested lists
            const lists = clone.querySelectorAll('ul');
            lists.forEach(ul => {
                const items = Array.from(ul.querySelectorAll('li')).map(li => li.textContent).join('\n');
                ul.replaceWith(document.createTextNode(items));
            });
            
            // Get the final text content and clean up extra whitespace
            return clone.textContent.replace(/\n{3,}/g, '\n\n').trim();
        }

        function showCopySuccess(button) {
            if (!button) return;
            
            const originalContent = button.innerHTML;
            const originalTitle = button.title;
            
            // Show success icon
            button.innerHTML = `
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="20,6 9,17 4,12"></polyline>
                </svg>
            `;
            button.title = 'Copied!';
            button.classList.add('copy-success');
            
            // Reset after 2 seconds
            setTimeout(() => {
                button.innerHTML = originalContent;
                button.title = originalTitle;
                button.classList.remove('copy-success');
            }, 2000);
        }

        function showCopyError(button) {
            if (!button) return;
            
            const originalContent = button.innerHTML;
            const originalTitle = button.title;
            
            // Show error icon
            button.innerHTML = `
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"></circle>
                    <line x1="15" y1="9" x2="9" y2="15"></line>
                    <line x1="9" y1="9" x2="15" y2="15"></line>
                </svg>
            `;
            button.title = 'Copy failed';
            button.classList.add('copy-error');
            
            // Reset after 2 seconds
            setTimeout(() => {
                button.innerHTML = originalContent;
                button.title = originalTitle;
                button.classList.remove('copy-error');
            }, 2000);
        }

        // Input blocking functionality
        function isWaitingForResponse() {
            const chatMessages = document.getElementById('chatMessages');
            const messages = chatMessages.querySelectorAll('.message:not(.typing-indicator)');
            
            if (messages.length === 0) return false;
            
            const lastMessage = messages[messages.length - 1];
            return lastMessage.classList.contains('user-message');
        }

        function setWaitingForResponse(waiting) {
            const messageInput = document.getElementById('messageInput');
            const sendBtn = document.getElementById('sendBtn');
            
            if (waiting) {
                messageInput.disabled = true;
                messageInput.placeholder = "Waiting for response...";
                sendBtn.disabled = true;
                sendBtn.style.opacity = '0.5';
                sendBtn.style.cursor = 'not-allowed';
            } else {
                messageInput.disabled = false;
                messageInput.placeholder = "Type your message here...";
                sendBtn.disabled = false;
                sendBtn.style.opacity = '1';
                sendBtn.style.cursor = 'pointer';
            }
        }

        function checkIfWaitingForResponse() {
            if (isWaitingForResponse()) {
                setWaitingForResponse(true);
            }
        }

        // Action buttons functionality for edited messages
        function addActionButtonsToEditedMessage(messageDiv, editedMessage, parentMessageId) {
            // Remove any existing action buttons
            const existingActions = messageDiv.querySelector('.message-actions');
            if (existingActions) {
                existingActions.remove();
            }

            const actionsDiv = document.createElement('div');
            actionsDiv.className = 'message-actions';
            actionsDiv.innerHTML = `
                <button class="action-btn delete-btn" onclick="deleteEditedMessage(this, '${parentMessageId}')" title="Delete message and revert branch">🗑️</button>
                <button class="action-btn retry-btn" onclick="retryEditedMessage(this, '${editedMessage.replace(/'/g, "\\'")}', '${parentMessageId}')" title="Resend edited message">🔄</button>
                <button class="action-btn edit-btn" onclick="editEditedMessage(this, '${editedMessage.replace(/'/g, "\\'")}', '${parentMessageId}')" title="Edit message again">✏️</button>
            `;
            messageDiv.appendChild(actionsDiv);
            messageDiv.dataset.originalMessage = editedMessage;
            messageDiv.dataset.parentMessageId = parentMessageId;
        }

        function deleteEditedMessage(button, parentMessageId) {
            const messageDiv = button.closest('.message');
            if (messageDiv && confirm('Are you sure you want to delete this message and revert the branch changes?')) {
                // Store the current tree path for restoration
                const originalTreePath = currentTreePath;
                
                // Remove the message from DOM
                messageDiv.remove();
                
                // Revert parent bot message connections in currentSessionMessages
                const parentBotIndex = currentSessionMessages.findIndex(msg => 
                    (msg.id || msg.message_id).toString() === parentMessageId.toString()
                );
                
                if (parentBotIndex !== -1) {
                    const parentMsg = currentSessionMessages[parentBotIndex];
                    
                    // Get the user message ID that was being edited
                    const editedMessageId = messageDiv.dataset.messageId;
                    
                    if (editedMessageId && parentMsg.connects_to) {
                        // Remove the edited message from connects_to
                        const connectsToArray = parentMsg.connects_to.split(',').filter(id => 
                            id !== '' && id !== editedMessageId
                        );
                        
                        parentMsg.connects_to = connectsToArray.join(',');
                        parentMsg.connections = connectsToArray.length;
                        
                        // If connections became 1 or 0, remove branch navigation
                        if (parentMsg.connections <= 1) {
                            const userMessagesWithNav = document.querySelectorAll(`[data-connected-from="${parentMessageId}"] .branch-navigation-controls`);
                            userMessagesWithNav.forEach(nav => nav.remove());
                        }
                    }
                    
                    // Remove the edited user and bot messages from currentSessionMessages
                    currentSessionMessages = currentSessionMessages.filter(msg => {
                        const msgId = msg.id || msg.message_id;
                        return msgId.toString() !== editedMessageId;
                    });
                }
                
                // Restore original tree path
                currentTreePath = originalTreePath;
                updateURL();
                
                // Unblock input for normal messaging
                setWaitingForResponse(false);
                
                showSuccessMessage('Message deleted and branch changes reverted.');
            }
        }

        function retryEditedMessage(button, editedMessage, parentMessageId) {
            const messageDiv = button.closest('.message');
            if (messageDiv) {
                // Remove the failed message actions
                const actionsDiv = messageDiv.querySelector('.message-actions');
                if (actionsDiv) {
                    actionsDiv.remove();
                }
                
                // Show typing indicator
                showTypingIndicator();
                
                // Block input while processing
                setWaitingForResponse(true);
                
                // Retry the edit with the same message
                retryEditAttempt(messageDiv, editedMessage, parentMessageId);
            }
        }

        function editEditedMessage(button, editedMessage, parentMessageId) {
            const messageDiv = button.closest('.message');
            if (messageDiv) {
                // Remove action buttons
                const actionsDiv = messageDiv.querySelector('.message-actions');
                if (actionsDiv) {
                    actionsDiv.remove();
                }
                
                // Start inline editing again with the edited message
                const originalMessageId = messageDiv.dataset.messageId;
                startInlineEdit(messageDiv, originalMessageId, editedMessage);
            }
        }

        async function retryEditAttempt(messageDiv, editedMessage, parentMessageId) {
            try {
                const response = await makeAuthenticatedRequest(`/chatbot?session=${currentSessionId}`, {
                    method: 'POST',
                    body: JSON.stringify({ 
                        message: editedMessage,
                        parent_message_id: parentMessageId
                    })
                });
                
                const data = await response.json();
                hideTypingIndicator();
                
                if (response.ok && data.messages) {
                    // Get the new user and bot messages from the response
                    const newUserMessage = data.messages.find(m => m.sender === 'user');
                    const newBotMessage = data.messages.find(m => m.sender === 'bot');
                    
                    if (newUserMessage && newBotMessage) {
                        // Add the new bot message to the chat immediately
                        const botDiv = addMessageToChat('bot', newBotMessage.content, null, false, newBotMessage);
                        
                        // Update the message div with new message data
                        messageDiv.dataset.messageId = newUserMessage.id;
                        messageDiv.dataset.connectedFrom = newUserMessage.connected_from || '';
                        messageDiv.dataset.connectsTo = newUserMessage.connects_to || '';
                        messageDiv.dataset.connections = newUserMessage.connections || 0;
                        
                        // Update stored session messages with the new branch messages
                        if (data.messages) {
                            data.messages.forEach(newMsg => {
                                const existingIndex = currentSessionMessages.findIndex(msg => 
                                    (msg.id || msg.message_id) === (newMsg.id || newMsg.message_id)
                                );
                                if (existingIndex === -1) {
                                    currentSessionMessages.push(newMsg);
                                } else {
                                    currentSessionMessages[existingIndex] = newMsg;
                                }
                            });
                        }
                        
                        // Update parent bot message connections
                        const parentBotIndex = currentSessionMessages.findIndex(msg => 
                            (msg.id || msg.message_id).toString() === parentMessageId.toString()
                        );
                        if (parentBotIndex !== -1) {
                            const parentMsg = currentSessionMessages[parentBotIndex];
                            const currentConnectsTo = parentMsg.connects_to || '';
                            const connectsToArray = currentConnectsTo ? currentConnectsTo.split(',').filter(id => id !== '') : [];
                            
                            if (!connectsToArray.includes(newUserMessage.id.toString())) {
                                connectsToArray.push(newUserMessage.id.toString());
                                parentMsg.connects_to = connectsToArray.join(',');
                                parentMsg.connections = Math.max(connectsToArray.length, 2);
                            }
                        }
                        
                        // Delete the last bot response from screen to prevent duplicates
                        const allBotMessages = document.querySelectorAll('.bot-message:not(.typing-indicator)');
                        if (allBotMessages.length > 0) {
                            const lastBotMessage = allBotMessages[allBotMessages.length - 1];
                            lastBotMessage.remove();
                        }
                        
                        // Calculate new tree path and update navigation
                        const newTreePath = await calculateNewBranchTreePath(parentMessageId, newUserMessage.id, newBotMessage.id);
                        currentTreePath = newTreePath;
                        updateURL();
                        
                        // Update branch navigation after delay
                        setTimeout(() => {
                            updateBranchNavigation(parentMessageId);
                        }, 100);
                        
                        showSuccessMessage('Message resent successfully!');
                    }
                } else {
                    showErrorMessage(data.message || 'Failed to resend message');
                    addActionButtonsToEditedMessage(messageDiv, editedMessage, parentMessageId);
                }
            } catch (error) {
                console.error('Retry edit error:', error);
                showErrorMessage('Failed to resend message. Please try again.');
                hideTypingIndicator();
                addActionButtonsToEditedMessage(messageDiv, editedMessage, parentMessageId);
            } finally {
                setWaitingForResponse(false);
            }
        }

        function updateBranchNavigation(parentMessageId) {
            const parentBotIndex = currentSessionMessages.findIndex(msg => 
                (msg.id || msg.message_id).toString() === parentMessageId.toString()
            );
            if (parentBotIndex !== -1) {
                const parentMsg = currentSessionMessages[parentBotIndex];
                
                // Find ALL user messages that connect from this bot message and update their navigation
                const userMessagesWithBranches = currentSessionMessages.filter(msg => 
                    msg.sender === 'user' && msg.connected_from === parentMessageId.toString()
                );
                
                userMessagesWithBranches.forEach(userMsg => {
                    if (parentMsg.connections > 1) {
                        const userMessageDiv = document.querySelector(`[data-message-id="${userMsg.id}"]`);
                        if (userMessageDiv) {
                            // Remove existing navigation controls if any
                            const existingNav = userMessageDiv.querySelector('.branch-navigation-controls');
                            if (existingNav) {
                                existingNav.remove();
                            }
                            
                            // Add new navigation controls to the user message
                            const navigationDiv = addBranchNavigationControls(userMessageDiv, {
                                id: userMsg.id,
                                connects_to: parentMsg.connects_to,
                                connections: parentMsg.connections,
                                parent_bot_id: parentMsg.id,
                                connected_from: parentMsg.id
                            });
                            if (navigationDiv) {
                                userMessageDiv.appendChild(navigationDiv);
                            }
                        }
                    }
                });
            }
        }

        // Action buttons functionality
        function addActionButtonsToMessage(messageDiv, originalMessage) {
            // Check if actions already exist
            if (messageDiv.querySelector('.message-actions')) {
                return;
            }

            const actionsDiv = document.createElement('div');
            actionsDiv.className = 'message-actions';
            actionsDiv.innerHTML = `
                <button class="action-btn delete-btn" onclick="deleteMessage(this)" title="Delete message">🗑️</button>
                <button class="action-btn retry-btn" onclick="retryMessage(this)" title="Try again">🔄</button>
                <button class="action-btn edit-btn" onclick="editMessage(this)" title="Edit message">✏️</button>
            `;
            messageDiv.appendChild(actionsDiv);
            messageDiv.dataset.originalMessage = originalMessage;
        }

        function deleteMessage(button) {
            const messageDiv = button.closest('.message');
            if (messageDiv && confirm('Are you sure you want to delete this message?')) {
                messageDiv.remove();
            }
        }

        function retryMessage(button) {
            const messageDiv = button.closest('.message');
            if (messageDiv) {
                const originalMessage = messageDiv.dataset.originalMessage || messageDiv.querySelector('.message-content').textContent;
                // Remove the failed message
                messageDiv.remove();
                // Send the message again
                document.getElementById('messageInput').value = originalMessage;
                sendMessage();
            }
        }

        function editMessage(button) {
            const messageDiv = button.closest('.message');
            if (messageDiv) {
                // Store scroll positions before editing
                const chatMessages = document.getElementById('chatMessages');
                const scrollPos = chatMessages ? chatMessages.scrollTop : 0;
                const windowScrollPos = window.pageYOffset;
                
                const originalMessage = messageDiv.dataset.originalMessage || messageDiv.querySelector('.message-content').textContent;
                // Remove the failed message
                messageDiv.remove();
                // Put the message back in the input for editing
                const messageInput = document.getElementById('messageInput');
                messageInput.value = originalMessage;
                
                // Enhanced focus without causing scroll jump
                setTimeout(() => {
                    messageInput.focus();
                    adjustTextareaHeight();
                    
                    // Restore both scroll positions with multiple attempts
                    [10, 20, 50, 100].forEach(delay => {
                        setTimeout(() => {
                            if (chatMessages) {
                                chatMessages.scrollTop = scrollPos;
                            }
                            if (window.pageYOffset !== windowScrollPos) {
                                window.scrollTo(0, windowScrollPos);
                                document.documentElement.scrollTop = windowScrollPos;
                                document.body.scrollTop = windowScrollPos;
                            }
                        }, delay);
                    });
                }, 10);
                
                // Unblock input in case it was blocked
                setWaitingForResponse(false);
            }
        }

        // ChatGPT-Style Branching Functions
        function addUserMessageEditControls(messageDiv, messageData, originalMessage) {
            if (!messageData || !messageData.id) return null;
            
            const controlsDiv = document.createElement('div');
            controlsDiv.className = 'user-edit-controls';
            controlsDiv.id = `edit-controls-${messageData.id}`;
            
            controlsDiv.innerHTML = `
                <button class="edit-message-btn" onclick="editUserMessage('${messageData.id}', '${originalMessage.replace(/'/g, "\\'")}')">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path>
                    </svg>
                </button>
                <button class="cancel-edit-btn" id="cancel-edit-${messageData.id}" onclick="cancelUserMessageEdit('${messageData.id}')" style="display: none;">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </button>
            `;
            
            return controlsDiv;
        }
        
        function addBranchNavigationControls(messageDiv, messageData) {
            if (!messageData || !messageData.connects_to || messageData.connections <= 1) {
                return null;
            }
            
            const navigationDiv = document.createElement('div');
            navigationDiv.className = 'branch-navigation-controls';
            
            // Get current branch index based on parent bot message branches
            const branchIds = messageData.connects_to.split(',');
            const parentBotId = messageData.parent_bot_id || messageData.connected_from; // Use connected_from as the correct parent bot ID
            const currentBranchIndex = getCurrentBranchIndex(parentBotId, branchIds);
            
            navigationDiv.innerHTML = `
                <div class="branch-nav-display">
                    <button class="nav-arrow nav-left" onclick="navigateToPreviousBranch('${parentBotId}')" ${currentBranchIndex === 0 ? 'disabled' : ''}>
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="15,18 9,12 15,6"></polyline>
                        </svg>
                    </button>
                    <span class="branch-counter">${currentBranchIndex + 1}/${branchIds.length}</span>
                    <button class="nav-arrow nav-right" onclick="navigateToNextBranch('${parentBotId}')" ${currentBranchIndex === branchIds.length - 1 ? 'disabled' : ''}>
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="9,18 15,12 9,6"></polyline>
                        </svg>
                    </button>
                </div>
            `;
            
            // Created branch navigation for message
            return navigationDiv;
        }
        
        async function editUserMessage(messageId, originalMessage) {
            if (!currentSessionId || isGuest) {
                showErrorMessage('Editing is only available for authenticated users in saved sessions.');
                return;
            }
            
            // Find the message div
            const messageDiv = document.querySelector(`[data-message-id="${messageId}"]`);
            if (!messageDiv) {
                showErrorMessage('Message not found.');
                return;
            }
            
            // Show cancel button and hide edit button
            const editBtn = messageDiv.querySelector('.edit-message-btn');
            const cancelBtn = messageDiv.querySelector('.cancel-edit-btn');
            
            if (editBtn) editBtn.style.display = 'none';
            if (cancelBtn) cancelBtn.style.display = 'inline-flex';
            
            // Start inline editing
            startInlineEdit(messageDiv, messageId, originalMessage);
        }
        
        function cancelUserMessageEdit(messageId) {
            // Find the message div
            const messageDiv = document.querySelector(`[data-message-id="${messageId}"]`);
            if (!messageDiv) return;
            
            // Hide cancel button and show edit button
            const editBtn = messageDiv.querySelector('.edit-message-btn');
            const cancelBtn = messageDiv.querySelector('.cancel-edit-btn');
            
            if (editBtn) editBtn.style.display = 'inline-flex';
            if (cancelBtn) cancelBtn.style.display = 'none';
            
            // Cancel the inline editing
            cancelInlineEdit(messageDiv);
        }
        
        function startInlineEdit(messageDiv, messageId, originalMessage) {
            const messageContent = messageDiv.querySelector('.message-content');
            if (!messageContent) return;
            
            // Store scroll positions before editing
            const chatMessages = document.getElementById('chatMessages');
            const scrollPos = chatMessages ? chatMessages.scrollTop : 0;
            const windowScrollPos = window.pageYOffset;
            
            // Store original content
            const originalContentHTML = messageContent.innerHTML;
            
            // Create edit interface
            const editContainer = document.createElement('div');
            editContainer.className = 'inline-edit-container';
            
            const textarea = document.createElement('textarea');
            textarea.className = 'inline-edit-textarea';
            textarea.value = originalMessage;
            textarea.rows = Math.max(2, originalMessage.split('\n').length);
            
            const buttonContainer = document.createElement('div');
            buttonContainer.className = 'inline-edit-buttons';
            
            const sendButton = document.createElement('button');
            sendButton.className = 'inline-edit-send';
            sendButton.innerHTML = '✓';
            sendButton.title = 'Send edited message';
            
            const cancelButton = document.createElement('button');
            cancelButton.className = 'inline-edit-cancel';
            cancelButton.innerHTML = '✕';
            cancelButton.title = 'Cancel editing';
            
            buttonContainer.appendChild(sendButton);
            buttonContainer.appendChild(cancelButton);
            editContainer.appendChild(textarea);
            editContainer.appendChild(buttonContainer);
            
            // Replace message content with edit interface
            messageContent.innerHTML = '';
            messageContent.appendChild(editContainer);
            
            // Enhanced focus with aggressive scroll protection
            setTimeout(() => {
                textarea.focus();
                textarea.select();
                
                // Multiple restoration attempts for both chat and window scroll
                [10, 20, 50, 100, 200].forEach(delay => {
                    setTimeout(() => {
                        if (chatMessages) {
                            chatMessages.scrollTop = scrollPos;
                        }
                        if (window.pageYOffset !== windowScrollPos) {
                            window.scrollTo(0, windowScrollPos);
                            document.documentElement.scrollTop = windowScrollPos;
                            document.body.scrollTop = windowScrollPos;
                        }
                    }, delay);
                });
            }, 10);
            
            // Auto-resize textarea
            function adjustTextareaHeight() {
                textarea.style.height = 'auto';
                const newHeight = Math.max(textarea.scrollHeight, 44);
                textarea.style.height = newHeight + 'px';
                
                // Show scrollbar only if content exceeds reasonable height
                if (textarea.scrollHeight > 200) {
                    textarea.style.overflowY = 'auto';
                } else {
                    textarea.style.overflowY = 'hidden';
                }
            }
            
            textarea.addEventListener('input', adjustTextareaHeight);
            adjustTextareaHeight();
            
            // Handle send button click
            sendButton.addEventListener('click', () => {
                const newMessage = textarea.value.trim();
                if (newMessage && newMessage !== originalMessage) {
                    submitEditedMessage(messageId, newMessage, messageDiv, originalContentHTML);
                } else {
                    cancelEdit(messageContent, originalContentHTML);
                }
            });
            
            // Handle cancel button click
            cancelButton.addEventListener('click', () => {
                const messageDiv = messageContent.closest('.message');
                const messageId = messageDiv ? messageDiv.dataset.messageId : null;
                if (messageId) {
                    cancelUserMessageEdit(messageId);
                } else {
                    cancelEdit(messageContent, originalContentHTML);
                }
            });
            
            // Handle keyboard shortcuts
            textarea.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    const newMessage = textarea.value.trim();
                    if (newMessage && newMessage !== originalMessage) {
                        submitEditedMessage(messageId, newMessage, messageDiv, originalContentHTML);
                    } else {
                        cancelEdit(messageContent, originalContentHTML);
                        // Reset buttons when canceling
                        const messageDiv = messageContent.closest('.message');
                        if (messageDiv) {
                            const editBtn = messageDiv.querySelector('.edit-message-btn');
                            const cancelBtn = messageDiv.querySelector('.cancel-edit-btn');
                            if (editBtn) editBtn.style.display = 'inline-flex';
                            if (cancelBtn) cancelBtn.style.display = 'none';
                        }
                    }
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    const messageDiv = messageContent.closest('.message');
                    const messageId = messageDiv ? messageDiv.dataset.messageId : null;
                    if (messageId) {
                        cancelUserMessageEdit(messageId);
                    } else {
                        cancelEdit(messageContent, originalContentHTML);
                    }
                }
            });
        }
        
        function cancelEdit(messageContent, originalContentHTML) {
            messageContent.innerHTML = originalContentHTML;
        }
        
        function cancelInlineEdit(messageDiv) {
            // Find the message content and restore original
            const messageContent = messageDiv.querySelector('.message-content');
            if (!messageContent) return;
            
            // Get the original message text from the data attribute or reconstruct it
            const messageId = messageDiv.dataset.messageId;
            const originalMessage = messageDiv.dataset.originalMessage;
            
            if (originalMessage) {
                // Restore the original message content
                messageContent.innerHTML = `<div class="message-text">${originalMessage}</div>`;
            } else {
                // If no stored original, try to get from session messages
                const sessionMessage = currentSessionMessages.find(msg => 
                    (msg.id || msg.message_id).toString() === messageId.toString()
                );
                if (sessionMessage) {
                    messageContent.innerHTML = `<div class="message-text">${sessionMessage.content}</div>`;
                }
            }
        }
        
        function removeAllSubsequentMessages(fromMessageId) {
            // This function removes all messages that come after the specified message ID
            // in the conversation flow, creating a clean slate for the new branch
            
            console.log(`Removing all messages after message ID: ${fromMessageId}`);
            
            if (!currentSessionMessages || currentSessionMessages.length === 0) {
                console.log('No session messages available for cleanup');
                return;
            }
            
            // Find the message we're editing
            const editMessage = currentSessionMessages.find(msg => 
                (msg.id || msg.message_id).toString() === fromMessageId.toString()
            );
            
            if (!editMessage) {
                console.log(`Message ${fromMessageId} not found in session messages`);
                return;
            }
            
            // Get the creation time of the edited message for comparison
            const editMessageTime = new Date(editMessage.created_at);
            
            // Find all messages that come after this message chronologically
            const messagesToRemove = currentSessionMessages.filter(msg => {
                const msgTime = new Date(msg.created_at);
                return msgTime > editMessageTime;
            });
            
            console.log(`Found ${messagesToRemove.length} messages to remove after edit point`);
            
            // Remove these messages from the DOM
            messagesToRemove.forEach(msg => {
                const msgId = msg.id || msg.message_id;
                const messageDiv = document.querySelector(`[data-message-id="${msgId}"]`);
                if (messageDiv) {
                    console.log(`Removing message ${msgId} (${msg.sender}) from DOM`);
                    messageDiv.remove();
                } else {
                    console.log(`Message ${msgId} not found in DOM (may have been already removed)`);
                }
            });
            
            // Also remove any messages that are directly connected to the edited message
            // (immediate responses that should be replaced)
            if (editMessage.connects_to) {
                const connectedIds = editMessage.connects_to.split(',').filter(id => id.trim() !== '');
                connectedIds.forEach(connectedId => {
                    const connectedDiv = document.querySelector(`[data-message-id="${connectedId}"]`);
                    if (connectedDiv) {
                        console.log(`Removing directly connected message ${connectedId} from DOM`);
                        connectedDiv.remove();
                    }
                });
            }
        }
        
        async function submitEditedMessage(messageId, newMessage, messageDiv, originalContentHTML) {
            const messageContent = messageDiv.querySelector('.message-content');
            
            // Replace the edited message content with the new message immediately
            const processedMessage = processCodeBlocks(newMessage);
            messageContent.innerHTML = processedMessage;
            
            // IMPORTANT: Remove ALL subsequent messages since we're creating a new branch
            // This includes the immediate bot response and everything that followed
            removeAllSubsequentMessages(messageId);
            
            // Show typing indicator for bot response
            showTypingIndicator();
            
            // Block input while processing
            setWaitingForResponse(true);
            
            try {
                // If currentSessionMessages is empty, wait a bit for it to be populated
                if (currentSessionMessages.length === 0) {
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
                
                // Find the parent message (the bot message that this user message responded to)
                const parentMessageId = await getParentBotMessage(messageId);
                
                if (!parentMessageId) {
                    console.error(`Could not find parent message for user message ${messageId}`);
                    showErrorMessage('Cannot create branch: Unable to find parent message. Please refresh the page and try again.');
                    cancelEdit(messageContent, originalContentHTML);
                    hideTypingIndicator();
                    return;
                }
                
                const response = await makeAuthenticatedRequest(`/chatbot?session=${currentSessionId}`, {
                    method: 'POST',
                    body: JSON.stringify({ 
                        message: newMessage,
                        parent_message_id: parentMessageId
                    })
                });
                
                const data = await response.json();
                hideTypingIndicator();
                
                if (response.ok && data.messages) {
                    // Get the new user and bot messages from the response
                    const newUserMessage = data.messages.find(m => m.sender === 'user');
                    const newBotMessage = data.messages.find(m => m.sender === 'bot');
                    
                    if (newUserMessage && newBotMessage) {
                        // Clean up session messages data - remove all messages after the edit point chronologically
                        const editMessage = currentSessionMessages.find(msg => 
                            (msg.id || msg.message_id).toString() === messageId.toString()
                        );
                        
                        if (editMessage) {
                            const editMessageTime = new Date(editMessage.created_at);
                            
                            // Filter out messages that come after the edited message chronologically
                            const originalLength = currentSessionMessages.length;
                            currentSessionMessages = currentSessionMessages.filter(msg => {
                                const msgTime = new Date(msg.created_at);
                                return msgTime <= editMessageTime;
                            });
                            
                            console.log(`Cleaned session messages: removed ${originalLength - currentSessionMessages.length} messages after edit point, kept ${currentSessionMessages.length} messages`);
                        }
                        
                        // Add the new bot message to the chat immediately
                        const botDiv = addMessageToChat('bot', newBotMessage.content, null, false, newBotMessage);
                        
                        // Update the message div with new message data
                        messageDiv.dataset.messageId = newUserMessage.id;
                        messageDiv.dataset.connectedFrom = newUserMessage.connected_from || '';
                        messageDiv.dataset.connectsTo = newUserMessage.connects_to || '';
                        messageDiv.dataset.connections = newUserMessage.connections || 0;
                        
                        // Add the new branch messages to session data
                        if (data.messages) {
                            data.messages.forEach(newMsg => {
                                // Check if message already exists (avoid duplicates)
                                const existingIndex = currentSessionMessages.findIndex(msg => 
                                    (msg.id || msg.message_id) === (newMsg.id || newMsg.message_id)
                                );
                                if (existingIndex === -1) {
                                    currentSessionMessages.push(newMsg);
                                    console.log(`Added new message ${newMsg.id} (${newMsg.sender}) to session data`);
                                } else {
                                    // Update existing message with new data
                                    currentSessionMessages[existingIndex] = newMsg;
                                    console.log(`Updated existing message ${newMsg.id} (${newMsg.sender}) in session data`);
                                }
                            });
                        }
                        
                        // Update the parent bot message's connection count in currentSessionMessages
                        const parentBotIndex = currentSessionMessages.findIndex(msg => 
                            (msg.id || msg.message_id).toString() === parentMessageId.toString()
                        );
                        if (parentBotIndex !== -1) {
                            const parentMsg = currentSessionMessages[parentBotIndex];
                            
                            // Update connects_to to include the new user message
                            const currentConnectsTo = parentMsg.connects_to || '';
                            const connectsToArray = currentConnectsTo ? currentConnectsTo.split(',').filter(id => id !== '') : [];
                            
                            if (!connectsToArray.includes(newUserMessage.id.toString())) {
                                connectsToArray.push(newUserMessage.id.toString());
                                parentMsg.connects_to = connectsToArray.join(',');
                                
                                // Artificially increase connections count for proper branching display
                                parentMsg.connections = Math.max(connectsToArray.length, 2);
                            }
                        }
                        
                        // Calculate the new tree path
                        const newTreePath = await calculateNewBranchTreePath(parentMessageId, newUserMessage.id, newBotMessage.id);
                        currentTreePath = newTreePath;
                        updateURL();
                        
                        // Save the new tree path to database
                        saveLastTreePath(currentSessionId, newTreePath);
                        
                        // Save the new tree path to database
                        saveLastTreePath(currentSessionId, newTreePath);
                        
                        // Update branch navigation controls after a small delay
                        setTimeout(() => {
                            const parentBotIndex = currentSessionMessages.findIndex(msg => 
                                (msg.id || msg.message_id).toString() === parentMessageId.toString()
                            );
                            if (parentBotIndex !== -1) {
                                const parentMsg = currentSessionMessages[parentBotIndex];
                                
                                // Find the currently edited user message that connects from this bot message and add navigation
                                // Use the specific message div we're working with instead of searching
                                if (parentMsg.connections > 1) {
                                    // Remove existing navigation controls if any
                                    const existingNav = messageDiv.querySelector('.branch-navigation-controls');
                                    if (existingNav) {
                                        existingNav.remove();
                                    }
                                    
                                    // Add new navigation controls to the current user message
                                    const navigationDiv = addBranchNavigationControls(messageDiv, {
                                        id: newUserMessage.id,
                                        connects_to: parentMsg.connects_to,
                                        connections: parentMsg.connections,
                                        parent_bot_id: parentMsg.id,
                                        connected_from: parentMsg.id
                                    });
                                    if (navigationDiv) {
                                        messageDiv.appendChild(navigationDiv);
                                    }
                                }
                            }
                        }, 100);
                        
                        // Check if session title has changed and update sidebar
                        if (data.title && currentSessionId && data.session_id === currentSessionId) {
                            updateSessionTitleInSidebar(currentSessionId, data.title);
                        }
                        
                        // Refresh sessions list to reflect potential title changes and reorder by lastChangeMade
                        if (currentSessionId && !isGuest) {
                            console.log('🔄 Refreshing sessions list after message edit/branch creation...');
                            resetSessionsState();
                            loadSessions(1);
                        }
                        
                        showSuccessMessage('Message edited and new branch created! Showing new branch.');
                    } else {
                        // Fallback: reload the entire session
                        await loadSession(currentSessionId);
                        showSuccessMessage('Message edited and new branch created!');
                    }
                } else {
                    showErrorMessage(data.message || 'Failed to edit message');
                    cancelEdit(messageContent, originalContentHTML);
                    
                    // Add action buttons for failed edit attempt (resend, edit, delete)
                    addActionButtonsToEditedMessage(messageDiv, newMessage, parentMessageId);
                }
            } catch (error) {
                console.error('Edit message error:', error);
                showErrorMessage('Failed to edit message. Please try again.');
                cancelEdit(messageContent, originalContentHTML);
                hideTypingIndicator();
                
                // Add action buttons for failed edit attempt (resend, edit, delete)
                addActionButtonsToEditedMessage(messageDiv, newMessage, parentMessageId);
            } finally {
                setWaitingForResponse(false);
            }
        }
        
        async function getParentBotMessage(userMessageId) {
            // getParentBotMessage called for user message
            
            // First try to get from stored session messages
            const allMessages = getCurrentSessionMessages();
            console.log(`  - Found ${allMessages.length} stored session messages`);
            
            if (allMessages && allMessages.length > 0) {
                const userMessage = allMessages.find(msg => {
                    const msgId = msg.id || msg.message_id;
                    return msgId && msgId.toString() === userMessageId.toString();
                });
                if (userMessage) {
                    console.log(`  - Found user message in session data:`, userMessage);
                    if (userMessage.connected_from) {
                        console.log(`  - Found parent from session data: ${userMessage.connected_from} for user message ${userMessageId}`);
                        return userMessage.connected_from;
                    } else {
                        console.log(`  - User message has no connected_from field`);
                    }
                } else {
                    console.log(`  - User message ${userMessageId} not found in session data`);
                    console.log(`  - Available message IDs:`, allMessages.map(m => m.id || m.message_id));
                }
            } else {
                console.log(`  - No stored session messages available`);
            }
            
            // Fallback to DOM data
            const messageDiv = document.querySelector(`[data-message-id="${userMessageId}"]`);
            if (messageDiv) {
                console.log(`  - Found parent from DOM: ${messageDiv.dataset.connectedFrom} for user message ${userMessageId}`);
                return messageDiv.dataset.connectedFrom;
            }
            
            console.log(`  - No parent found for user message ${userMessageId}`);
            return null;
        }
        
        // Tree path persistence functions
        async function saveLastTreePath(sessionId, treePath) {
            if (!sessionId || sessionId === 'guest' || !treePath) return;
            
            // Önce tree path'i genişletmeye çalış
            const extendedPath = await extendTreePathWithNewMessages(sessionId, treePath);
            
            try {
                console.log(`💾 Saving tree path for session ${sessionId}: ${extendedPath}`);
                const response = await makeAuthenticatedRequest(`/chatbot/save-tree-path`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        session_id: sessionId,
                        tree_path: extendedPath
                    })
                });
                
                if (response.ok) {
                    console.log('✅ Tree path saved successfully');
                    // Global currentTreePath'i de güncelle
                    if (sessionId === currentSessionId) {
                        currentTreePath = extendedPath;
                    }
                } else {
                    console.warn('❌ Failed to save tree path:', await response.text());
                }
            } catch (error) {
                console.error('❌ Error saving tree path:', error);
            }
        }

        async function extendTreePathWithNewMessages(sessionId, currentPath) {
            try {
                console.log('🔧 Extending tree path with new messages...');
                console.log('Current path:', currentPath);
                
                // Session mesajlarını al
                const response = await makeAuthenticatedRequest(`/chatbot/message?session=${sessionId}`, {
                    method: 'GET'
                });
                
                if (!response.ok) {
                    console.warn('Failed to fetch session messages for path extension');
                    return currentPath;
                }
                
                const data = await response.json();
                const messages = data.data || [];
                
                // Tree path'i genişlet
                const extendedPath = calculateLatestBranchPath(messages, currentPath);
                
                if (extendedPath !== currentPath) {
                    console.log('🔄 Path extended!');
                    console.log('Old path:', currentPath);
                    console.log('New path:', extendedPath);
                } else {
                    console.log('📋 No new messages to extend path');
                }
                
                return extendedPath;
            } catch (error) {
                console.error('Error extending tree path:', error);
                return currentPath; // Hata durumunda mevcut path'i döndür
            }
        }

        async function getLastTreePath(sessionId) {
            if (!sessionId || sessionId === 'guest') return null;
            
            try {
                console.log(`Retrieving last tree path for session ${sessionId}`);
                const response = await makeAuthenticatedRequest(`/chatbot/get-tree-path?session=${sessionId}`, {
                    method: 'GET'
                });
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('Retrieved tree path:', data.tree_path);
                    return data.tree_path;
                } else {
                    console.warn('Failed to retrieve tree path:', await response.text());
                    return null;
                }
            } catch (error) {
                console.error('Error retrieving tree path:', error);
                return null;
            }
        }

        function getCurrentSessionMessages() {
            return currentSessionMessages || [];
        }
        
        async function calculateNewBranchTreePath(parentBotId, newUserId, newBotId) {
            // Build the full tree path from the root of the conversation to the new branch
            try {
                // First try to use the stored session messages
                let messages = getCurrentSessionMessages();
                
                // If we don't have enough messages stored, fetch from server
                if (messages.length === 0) {
                    console.log('No stored messages, fetching from server for tree path calculation');
                    const response = await makeAuthenticatedRequest(`/chatbot/message?session=${currentSessionId}`, {
                        method: 'GET'
                    });
                    
                    if (!response.ok) {
                        console.error('Failed to get session messages for tree path calculation');
                        return `,${parentBotId},${newUserId},${newBotId}`;
                    }
                    
                    const data = await response.json();
                    messages = data.data || [];
                } else {
                    // Using stored session messages for tree path calculation
                }
                
                // Create a map of message ID to message for easy lookup
                const messageMap = {};
                messages.forEach(msg => {
                    // Ensure consistent string-based keys for lookup
                    messageMap[msg.id.toString()] = msg;
                });
                
                // Build the full path by tracing backward from parent to root, then forward
                const pathIds = [''];  // Start with empty string for root
                
                // Tracing path to parent bot
                
                // Simple backward tracing from parentBotId to root
                const backwardPath = [];
                let currentId = parentBotId.toString(); // Ensure string type
                
                while (currentId && messageMap[currentId]) {
                    const msg = messageMap[currentId];
                    backwardPath.unshift(currentId); // Add to beginning
                    console.log(`  ← ${currentId} (${msg.sender}) from ${msg.connected_from}`);
                    
                    if (msg.connected_from === 'main') {
                        break;
                    }
                    currentId = msg.connected_from ? msg.connected_from.toString() : null;
                }
                
                // Add the traced path
                pathIds.push(...backwardPath);
                
                // Add the new branch messages to the path
                pathIds.push(newUserId.toString(), newBotId.toString());
                
                const fullTreePath = pathIds.join(',');
                console.log('Calculated new branch tree path:', fullTreePath);
                return fullTreePath;
                
            } catch (error) {
                console.error('Error calculating tree path:', error);
                // Fallback to simple path with consistent string formatting
                return `,${parentBotId.toString()},${newUserId.toString()},${newBotId.toString()}`;
            }
        }
        
        async function loadSessionWithTreePath(sessionId, treePath) {
            try {
                console.log('Loading session with tree path:', sessionId, treePath);
                
                const response = await makeAuthenticatedRequest(`/chatbot/message?session=${sessionId}&tree=${encodeURIComponent(treePath)}`, {
                    method: 'GET'
                });

                const data = await response.json();

                if (response.ok) {
                    currentSessionId = sessionId;
                    currentTreePath = treePath;
                    
                    // Save the tree path to database
                    saveLastTreePath(sessionId, treePath);
                    
                    // Store complete session messages for branch navigation
                    const messages = data.data || [];
                    currentSessionMessages = messages;
                    
                    updateURL();
                    displayMessages(messages);
                    updateActiveSession(sessionId);
                    checkIfWaitingForResponse();
                    console.log('Successfully loaded session with tree path');
                } else {
                    console.error('Failed to load session with tree path:', data);
                    // Fallback to loading without tree path
                    await loadSession(sessionId);
                }
            } catch (error) {
                console.error('Load session with tree path error:', error);
                // Fallback to loading without tree path
                await loadSession(sessionId);
            }
        }
        
        function calculateMainTreePath(messages) {
            // Build the main conversation path by following connected_from relationships
            const path = [''];
            
            let currentMessageId = 'main';
            // Calculating main tree path
            
            while (true) {
                // Find the message connected FROM the current message
                const nextMessage = messages.find(msg => msg.connected_from === currentMessageId.toString());
                if (!nextMessage) {
                    console.log(`  No more messages connected from ${currentMessageId}`);
                    break;
                }
                
                // Add this message to the path
                path.push(nextMessage.id.toString());
                console.log(`  Added message ${nextMessage.id} (${nextMessage.sender}) to path`);
                
                // Move to this message and continue looking for what connects FROM it
                currentMessageId = nextMessage.id.toString();
                
                // If this message has multiple branches, we need to choose one for the main path
                if (nextMessage.connects_to) {
                    const branchIds = nextMessage.connects_to.split(',').filter(id => id !== '');
                    if (branchIds.length > 1) {
                        console.log(`  Message ${nextMessage.id} has ${branchIds.length} branches: ${branchIds.join(', ')}`);
                        console.log(`  Continuing main path with first connection`);
                        // Don't change currentMessageId here - let the loop find the connected message
                    }
                }
            }
            
            const treePath = path.join(',');
            // Main tree path calculated
            return treePath;
        }

        // FAILSAFE: Calculate path to the latest (most recent) branch tip
        function calculateLatestBranchPath(messages, currentTreePath = '') {
            console.log('🔧 SIMPLE: Extending tree path with new messages...');
            console.log('Starting with current tree path:', currentTreePath);
            
            if (!messages || messages.length === 0) {
                console.log('No messages found');
                return currentTreePath || '';
            }
            
            // Başlangıç path'i al - boşsa boş string kullan
            let extendedPath = currentTreePath || '';
            
            // Path'in son elemanını bul (virgüllerle ayrılmış)
            const pathParts = extendedPath.split(',').filter(part => part !== '');
            let lastMessageId = pathParts.length > 0 ? pathParts[pathParts.length - 1] : '';
            
            console.log('Last message ID in path:', lastMessageId);
            
            // Eğer path boşsa, ana daldan başla
            if (!lastMessageId) {
                const firstUserMessage = messages.find(msg => msg.sender === 'user' && (!msg.connected_from || msg.connected_from === 'main'));
                if (firstUserMessage) {
                    extendedPath = ',' + firstUserMessage.id;
                    lastMessageId = firstUserMessage.id.toString();
                    console.log('Started path with first user message:', lastMessageId);
                } else {
                    console.log('No starting user message found');
                    return '';
                }
            }
            
            // Döngü: son mesajın connects_to'suna bak ve varsa ekle
            let continueLoop = true;
            let loopCount = 0;
            const maxLoops = 100; // Sonsuz döngü koruması
            
            while (continueLoop && loopCount < maxLoops) {
                loopCount++;
                console.log(`Loop ${loopCount}: Checking message ${lastMessageId} for connects_to...`);
                
                // Son mesajı bul
                const lastMessage = messages.find(msg => msg.id.toString() === lastMessageId);
                if (!lastMessage) {
                    console.log('Last message not found, stopping');
                    break;
                }
                
                // connects_to kısmını kontrol et
                if (!lastMessage.connects_to || lastMessage.connects_to.trim() === '') {
                    console.log('No connects_to found, stopping');
                    continueLoop = false;
                } else {
                    // connects_to varsa, ilk değeri al (virgül varsa ilkini al)
                    const connectsToList = lastMessage.connects_to.split(',').filter(id => id.trim() !== '');
                    if (connectsToList.length > 0) {
                        const nextMessageId = connectsToList[0].trim(); // İlk değeri al
                        console.log(`Found connects_to: ${nextMessageId}`);
                        
                        // Bu mesajın gerçekten var olduğunu kontrol et
                        const nextMessage = messages.find(msg => msg.id.toString() === nextMessageId);
                        if (nextMessage) {
                            extendedPath += ',' + nextMessageId;
                            lastMessageId = nextMessageId;
                            console.log('Extended path:', extendedPath);
                        } else {
                            console.log('Next message not found in messages list, stopping');
                            continueLoop = false;
                        }
                    } else {
                        console.log('Empty connects_to list, stopping');
                        continueLoop = false;
                    }
                }
            }
            
            if (loopCount >= maxLoops) {
                console.warn('Maximum loop count reached, stopping to prevent infinite loop');
            }
            
            console.log('🎯 Final extended path:', extendedPath);
            return extendedPath;
        }

        // Enhanced calculateMainTreePath with failsafe
        function calculateMainTreePathWithFailsafe(messages, savedTreePath = '') {
            console.log('🚀 Calculating main tree path with failsafe...');
            console.log('Using saved tree path as base:', savedTreePath);
            
            // Eğer kaydedilmiş bir tree path varsa, onu genişletmeye çalış
            if (savedTreePath && savedTreePath.trim() !== '') {
                console.log('📋 Using saved tree path as starting point');
                return calculateLatestBranchPath(messages, savedTreePath);
            }
            
            // Eğer kaydedilmiş path yoksa, ana dalı hesapla ve genişlet
            console.log('🔧 No saved path, calculating from main tree');
            const mainPath = calculateMainTreePath(messages);
            
            // Ana dalı hesapladıktan sonra genişlet
            return calculateLatestBranchPath(messages, mainPath);
        }

        // Helper function to get the timestamp of the last message in a path
        function getPathLastTimestamp(messages, treePath) {
            const pathIds = treePath.split(',').filter(id => id !== '');
            if (pathIds.length === 0) return new Date(0);
            
            const lastPathId = pathIds[pathIds.length - 1];
            const lastMessage = messages.find(msg => msg.id.toString() === lastPathId);
            
            return lastMessage ? new Date(lastMessage.timestamp) : new Date(0);
        }

        function getCurrentBranchIndex(botMessageId, branchIds) {
            // getCurrentBranchIndex for bot message
            console.log(`  - Current tree path: ${currentTreePath}`);
            
            // Determine which branch we're currently viewing based on the tree path
            if (currentTreePath) {
                const pathIds = currentTreePath.split(',');
                console.log(`  - Tree path IDs: ${pathIds.join(', ')}`);
                
                // Look for any of the branch IDs (user message IDs) in our current path
                for (let i = 0; i < branchIds.length; i++) {
                    if (pathIds.includes(branchIds[i])) {
                        console.log(`  - Found branch ${branchIds[i]} in path at index ${i}`);
                        return i;
                    }
                }
            }
            
            // If no tree path or no match found, check which user message branch is currently visible
            // by looking in session messages first (more reliable than DOM)
            const allMessages = getCurrentSessionMessages();
            if (allMessages.length > 0) {
                // Find the most recently created user message that connects from this bot message
                const connectedUserMessages = allMessages.filter(msg => 
                    msg.sender === 'user' && 
                    msg.connected_from === botMessageId.toString()
                );
                
                if (connectedUserMessages.length > 0) {
                    // Sort by ID (assuming higher ID = more recent) and take the most recent
                    const mostRecentUserMessage = connectedUserMessages.sort((a, b) => 
                        parseInt(b.id) - parseInt(a.id)
                    )[0];
                    
                    const index = branchIds.indexOf(mostRecentUserMessage.id.toString());
                    if (index !== -1) {
                        console.log(`  - Found most recent user message ${mostRecentUserMessage.id} at branch index ${index}`);
                        return index;
                    }
                }
            }
            
            // Final fallback: check DOM visibility
            const visibleUserMessage = allMessages.find(msg => 
                msg.sender === 'user' && 
                msg.connected_from === botMessageId.toString() &&
                document.querySelector(`[data-message-id="${msg.id}"]`)
            );
            
            if (visibleUserMessage) {
                const index = branchIds.indexOf(visibleUserMessage.id.toString());
                if (index !== -1) {
                    console.log(`  - Found visible user message ${visibleUserMessage.id} at branch index ${index}`);
                    return index;
                }
            }
            
            console.log(`  - Defaulting to branch index 0`);
            return 0; // Default to first branch
        }
        
        async function navigateToPreviousBranch(botMessageId) {
            // Find the bot message in the session data to get its branches
            const allMessages = getCurrentSessionMessages();
            const botMessage = allMessages.find(msg => msg.id.toString() === botMessageId.toString());
            
            if (!botMessage || !botMessage.connects_to) return;
            
            const branchIds = botMessage.connects_to.split(',');
            const currentIndex = getCurrentBranchIndex(botMessageId, branchIds);
            
            if (currentIndex > 0) {
                const targetBranchId = branchIds[currentIndex - 1];
                await navigateToBranch(targetBranchId);
            }
        }
        
        async function navigateToNextBranch(botMessageId) {
            // Find the bot message in the session data to get its branches
            const allMessages = getCurrentSessionMessages();
            const botMessage = allMessages.find(msg => msg.id.toString() === botMessageId.toString());
            
            if (!botMessage || !botMessage.connects_to) return;
            
            const branchIds = botMessage.connects_to.split(',');
            const currentIndex = getCurrentBranchIndex(botMessageId, branchIds);
            
            if (currentIndex < branchIds.length - 1) {
                const targetBranchId = branchIds[currentIndex + 1];
                await navigateToBranch(targetBranchId);
            }
        }
        
        async function navigateToBranch(branchId) {
            if (!currentSessionId) return;
            
            try {
                console.log(`Navigating to branch ${branchId}`);
                
                // Store current scroll position before re-rendering
                const chatMessages = document.getElementById('chatMessages');
                const scrollPosition = chatMessages.scrollTop;
                
                // Instead of making a server request, calculate the new tree path
                // and re-display messages with the updated path
                
                // Get all messages from the current session (they should already be loaded)
                const response = await makeAuthenticatedRequest(`/chatbot/message?session=${currentSessionId}`, {
                    method: 'GET'
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    const allMessages = data.data || [];
                    
                    // Calculate new tree path that includes the target branch
                    const newTreePath = calculateTreePathToBranch(allMessages, branchId);
                    // New tree path calculated for branch
                    
                    currentTreePath = newTreePath;
                    
                    // Save the new tree path to database
                    saveLastTreePath(currentSessionId, newTreePath);
                    
                    // Re-enable filtering and display messages for this tree path
                    displayMessagesWithFiltering(allMessages);
                    
                    // Restore scroll position after a brief delay to allow DOM updates
                    setTimeout(() => {
                        chatMessages.scrollTop = scrollPosition;
                    }, 50);
                    
                    updateTreePathDisplay();
                } else {
                    showErrorMessage(data.message || 'Failed to navigate to branch');
                }
            } catch (error) {
                console.error('Navigate branch error:', error);
                showErrorMessage('Failed to navigate to branch. Please try again.');
            }
        }
        
        function calculateTreePathToBranch(messages, targetBranchId) {
            // Find the target message
            const targetMessage = messages.find(msg => msg.id.toString() === targetBranchId);
            if (!targetMessage) {
                console.error(`Target message ${targetBranchId} not found`);
                return '';
            }
            
            console.log(`Building tree path to branch ${targetBranchId}`);
            
            // Build path backwards from target to root
            const pathIds = [''];
            const reversePath = [];
            let currentId = targetMessage.id;
            
            // Trace back to root to get the leading context
            while (currentId) {
                const msg = messages.find(m => m.id.toString() === currentId.toString());
                if (!msg) break;
                
                reversePath.unshift(currentId.toString());
                console.log(`  Added ${currentId} (${msg.sender}) to reverse path`);
                
                if (msg.connected_from === 'main') {
                    break;
                }
                currentId = msg.connected_from ? msg.connected_from.toString() : null;
            }
            
            // Add the backward path to our main path
            pathIds.push(...reversePath);
            
            // Now continue forward from the target message to get the full branch conversation
            let currentMessage = targetMessage;
            while (currentMessage && currentMessage.connects_to) {
                const nextIds = currentMessage.connects_to.split(',').filter(id => id !== '');
                if (nextIds.length > 0) {
                    // Follow the first connection (for now, could be enhanced to follow all)
                    const nextId = nextIds[0];
                    const nextMessage = messages.find(m => m.id.toString() === nextId.toString());
                    if (nextMessage) {
                        pathIds.push(nextId.toString());
                        console.log(`  Extended path with ${nextId} (${nextMessage.sender})`);
                        currentMessage = nextMessage;
                    } else {
                        break;
                    }
                } else {
                    break;
                }
            }
            
            const finalPath = pathIds.join(',');
            console.log(`Final branch path: ${finalPath}`);
            return finalPath;
        }
        
        function displayMessagesWithFiltering(messages) {
            const chatMessages = document.getElementById('chatMessages');
            
            // Store typing indicator state before clearing
            const wasTypingActive = isTypingIndicatorActive;
            const typingIndicator = document.getElementById('typingIndicator');
            let typingHTML = '';
            if (typingIndicator && wasTypingActive) {
                typingHTML = typingIndicator.outerHTML;
            }
            
            chatMessages.innerHTML = '';

            if (messages.length === 0) {
                chatMessages.innerHTML = `
                    <div class="welcome-message">
                        <h3>Session Loaded! 👋</h3>
                        <p>Continue your conversation or start a new topic.</p>
                    </div>
                `;
                return;
            }

            // Clear conversation branches
            currentConversationBranches = {};

            // displayMessagesWithFiltering called
            // Current tree path logging

            // Filter messages based on current tree path
            let messagesToDisplay = messages;
            
            if (currentTreePath) {
                console.log(`Filtering messages by tree path: ${currentTreePath}`);
                const pathIds = currentTreePath.split(',').filter(id => id !== '');
                
                // Only show messages that are in the current tree path
                messagesToDisplay = messages.filter(msg => {
                    const isInPath = pathIds.includes(msg.id.toString());
                    return isInPath;
                });
                
                console.log(`Displaying ${messagesToDisplay.length} filtered messages out of ${messages.length} total`);
            } else {
                console.log('No tree path set, displaying all messages');
            }

            messagesToDisplay.forEach((msg, index) => {
                // Adding message to chat
                const messageDiv = addMessageToChat(msg.sender, msg.content, msg.created_at, false, msg, false); // Don't auto-scroll for branch navigation
                
                // Store branch information
                if (msg.connects_to && msg.connections > 0) {
                    currentConversationBranches[msg.id] = {
                        connects_to: msg.connects_to,
                        connections: msg.connections
                    };
                    
                    // Add visual indicator for messages with branches
                    messageDiv.classList.add('has-branches');
                }
            });
            
            // Restore typing indicator if it was active
            if (typingHTML && wasTypingActive) {
                chatMessages.insertAdjacentHTML('beforeend', typingHTML);
                // Restore global state
                isTypingIndicatorActive = true;
            }
            
            // displayMessagesWithFiltering completed
            
            // Update tree path display
            updateTreePathDisplay();
        }
        
        function updateBranchStructure(messages) {
            messages.forEach(msg => {
                if (msg.connects_to && msg.connections > 0) {
                    currentConversationBranches[msg.id] = {
                        connects_to: msg.connects_to,
                        connections: msg.connections
                    };
                }
            });
        }
        
        function updateTreePathDisplay() {
            // Disabled - user requested no branch display at the top
            // Branch navigation is handled through message-level controls instead
            return;
        }
        
        async function returnToMainBranch() {
            if (!currentSessionId) return;
            
            try {
                const response = await makeAuthenticatedRequest(`/chatbot/message?session=${currentSessionId}`, {
                    method: 'GET'
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    // Store complete session messages for branch navigation
                    const messages = data.data || [];
                    currentSessionMessages = messages;
                    
                    // Ana daldan başlayıp en son mesajlara kadar genişlet
                    if (messages.length > 0) {
                        console.log('🔄 Return to main branch - calculating extended main path...');
                        currentTreePath = calculateMainTreePathWithFailsafe(messages, '');
                        console.log('🔄 Return to main branch - new path:', currentTreePath);
                        // Yeni path'i veritabanına kaydet
                        saveLastTreePath(currentSessionId, currentTreePath);
                    } else {
                        currentTreePath = null;
                    }
                    
                    displayMessages(messages);
                    updateTreePathDisplay();
                } else {
                    showErrorMessage(data.message || 'Failed to return to main branch');
                }
            } catch (error) {
                console.error('Return to main branch error:', error);
                showErrorMessage('Failed to return to main branch. Please try again.');
            }
        }
        
        function getLastBotMessageFromCurrentBranch() {
            // If we have a tree path, use it to find the last bot message in the current branch
            if (currentTreePath && currentSessionMessages.length > 0) {
                const pathIds = currentTreePath.split(',').filter(id => id !== '');
                
                // Find bot messages that are in the current path, ordered by their position in the path
                const botMessagesInPath = [];
                pathIds.forEach(id => {
                    const message = currentSessionMessages.find(msg => 
                        msg.id.toString() === id && msg.sender === 'bot'
                    );
                    if (message) {
                        botMessagesInPath.push(message);
                    }
                });
                
                // Return the last bot message in the current path
                if (botMessagesInPath.length > 0) {
                    const lastBotMessage = botMessagesInPath[botMessagesInPath.length - 1];
                    return { id: lastBotMessage.id };
                }
            }
            
            // Fallback: look at visible bot messages in the DOM
            const messages = document.querySelectorAll('.message.bot-message');
            if (messages.length === 0) return null;
            
            const lastBotMessage = messages[messages.length - 1];
            const messageId = lastBotMessage.dataset.messageId;
            
            if (messageId) {
                return { id: messageId };
            }
            
            return null;
        }

        function showSuccessMessage(message) {
            // Remove any existing notifications
            const existingNotification = document.querySelector('.success-notification');
            if (existingNotification) {
                existingNotification.remove();
            }

            // Create success notification
            const successDiv = document.createElement('div');
            successDiv.className = 'success-notification';
            successDiv.innerHTML = `
                <div class="success-content">
                    <span class="success-icon">✅</span>
                    <span class="success-text">${message}</span>
                    <button class="success-close" onclick="this.parentElement.parentElement.remove()">×</button>
                </div>
            `;

            // Insert at the top of chat container
            const chatContainer = document.querySelector('.chat-container');
            chatContainer.insertBefore(successDiv, chatContainer.firstChild);

            // Auto-hide after 3 seconds
            setTimeout(() => {
                if (successDiv.parentNode) {
                    successDiv.remove();
                }
            }, 3000);
        }

        // Mobile viewport height fix for iOS Safari address bar
        function setViewportHeight() {
            let vh = window.innerHeight * 0.01;
            document.documentElement.style.setProperty('--vh', `${vh}px`);
        }

        // Set initial viewport height
        setViewportHeight();

        // Handle layout reset for mobile/desktop transitions
        function handleLayoutReset() {
            // Force a reflow to ensure proper layout
            document.body.offsetHeight;
            
            // Ensure chat messages scroll to bottom
            const chatMessages = document.getElementById('chatMessages');
            if (chatMessages) {
                setTimeout(() => {
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                }, 50);
            }
        }

        // Scroll to bottom utility function
        function scrollToBottom() {
            const chatMessages = document.getElementById('chatMessages');
            if (chatMessages) {
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }
        }

        // Update viewport height on resize/orientation change
        window.addEventListener('resize', () => {
            setViewportHeight();
            handleLayoutReset();
        });
        
        window.addEventListener('orientationchange', () => {
            // Close mobile sidebar on orientation change
            const sidebar = document.getElementById('sessionsSidebar');
            if (sidebar && sidebar.classList.contains('mobile-open')) {
                sidebar.classList.remove('mobile-open');
            }
        });

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Setup all event listeners first
            setupEventListeners();
            
            // Set initial viewport height
            setViewportHeight();
            
            // Load sessions if authenticated
            if (!isGuest) {
                loadSessions();
            }
            
            // Focus message input
            const messageInput = document.getElementById('messageInput');
            if (messageInput) {
                messageInput.focus();
            }
        });

        // Simple mobile focus behavior
        (function initMobileFocusBehavior(){
            const ta = document.getElementById('messageInput');
            const chatMessages = document.getElementById('chatMessages');
            if(!ta || !chatMessages) return;

            ta.addEventListener('focus', () => {
                // Natural behavior: just scroll messages to bottom
                requestAnimationFrame(()=> {
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                });
            });
        })();
    </script>
</body>

</html>